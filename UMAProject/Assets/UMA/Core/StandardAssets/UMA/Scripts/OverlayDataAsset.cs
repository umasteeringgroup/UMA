using UnityEngine;
using System.Collections;
using UnityEngine.Rendering;
#if UNITY_EDITOR
using UnityEditorInternal;
#endif


namespace UMA
{
    /// <summary>
    /// Contains the immutable data shared between overlays of the same type.
    /// </summary>
    [PreferBinarySerialization]
	[System.Serializable]
	public partial class OverlayDataAsset : ScriptableObject, ISerializationCallbackReceiver, IUMAIndexOptions
	{
		[Tooltip("The name of this overlay.")]
		public string overlayName;
		[System.NonSerialized]
		public int nameHash;

#if UNITY_EDITOR
		public float lastActionTime { get; set; } = 0;
		public bool doSave { get; set; } = false;
		public bool additionalFoldout { get; set; } = false;
		public bool textureFoldout { get; set; } = false;
		public bool tagsFoldout { get; set; } = false;
		public bool occlusionFoldout { get; set; } = false;

		public ReorderableList tagsList;
#endif
		public enum OverlayType
		{
			Normal = 0,
			Cutout = 1,
		}

		public enum OverlayBlend
		{
			Normal = 0,
			Multiply = BlendOp.Multiply,
			Overlay = BlendOp.Overlay,
			Screen = BlendOp.Screen,
			Darken = BlendOp.Darken,
			Lighten = BlendOp.Lighten,
			ColorDodge = BlendOp.ColorDodge,
			ColorBurn = BlendOp.ColorBurn,
			SoftLight = BlendOp.SoftLight,
			HardLight = BlendOp.HardLight,
			Subtract = BlendOp.Subtract
		}

		/// <summary>
		/// How should this overlay be processed.
		/// </summary>
		[Tooltip("Normal or Cutout overlay type. This determines whether or not to use a cutout shader during the texture merging process.")]
		public OverlayType overlayType;

		/// <summary>
		/// Destination rectangle for drawing overlay textures.
		/// </summary>
		[Tooltip("Destination rectangle for drawing overlay textures.")]
		public Rect rect;
		/// <summary>
		/// Optional Alpha mask, if alpha mask is not set the texture[0].alpha is used instead.
		/// Using a alpha mask also allows you to write alpha values from the texture[0] to cut holes
		/// </summary>
		[Tooltip("Optional Alpha mask, if alpha mask is not set the texture[0].alpha is used instead.")]
		public Texture alphaMask;
		/// <summary>
		/// Array of textures required for the overlay material.
		/// </summary>
		[Tooltip("Array of textures required for the overlay material.")]
		public Texture[] textureList = new Texture[1];

        [Tooltip("Overlay Blend Mode. Not used on the base overlay. Similar to standard blend modes on paint apps. Use the alpha channel ")]
        public OverlayBlend[] overlayBlend = new OverlayBlend[1];

        /// <summary>
        /// Use this to identify what kind of overlay this is and what it fits
        /// Eg. BaseMeshSkin, BaseMeshOverlays, GenericPlateArmor01
        /// </summary>
        [Tooltip("Use this to identify what kind of overlay this is and what it fits.")]
		public string[] tags;

		/// <summary>
		/// The UMA material.
		/// </summary>
		/// <remarks>
		/// The UMA material contains both a reference to the Unity material
		/// used for drawing and information needed for matching the textures
		/// and colors to the various material properties.
		/// </remarks>
		[Tooltip("The UMA material contains both a reference to the Unity material used for drawing and information needed for matching the textures and colors to the various material properties.")]
		[UMAAssetFieldVisible]
		public UMAMaterial material;

		/// <summary>
		/// materialName is used to save the name of the material, but ONLY if we have cleared the material when building bundles.
		/// You can't count on this field to contain a value unless it was set during the cleanup phase by the indexer!
		/// </summary>
		public string materialName;

		/// <summary>
		/// This overlay was auto generated as a LOD overlay based on another overlay.
		/// </summary>
		[SerializeField]
		[HideInInspector]
		public bool autoGeneratedLOD;

		/// <summary>
		/// The number of textures in the texture array.
		/// </summary>
		public int textureCount
		{
			get
			{
				if (textureList == null)
                {
                    return 0;
                }

                return textureList.Length;
			}
		}

        public bool forceKeep = false;
        public bool ForceKeep { get { return forceKeep; } set { forceKeep = value; } }

		[Tooltip("If true, this overlay will not be added to the index when adding all")]
        public bool noAutoAdd = false;
        public bool NoAutoAdd { get { return noAutoAdd; } set { noAutoAdd = value; } }

        private bool labelLocalFiles = false;
        public bool LabelLocalFiles { get { return labelLocalFiles; } set { labelLocalFiles = value; } }


		public OverlayBlend GetBlend(int channel)
		{
			if (channel >= overlayBlend.Length)
			{
				return OverlayBlend.Normal;
			}
			return overlayBlend[channel];
		}

		public void ValidateBlendList()
		{
			if (overlayBlend.Length != textureList.Length)
			{
				overlayBlend = new OverlayBlend[textureList.Length];
			}
		}

		/// <summary>
		/// Occlusion Entries for occluding triangles, currently only supported by powertools.
		/// </summary>
		[System.Serializable]
		public class OcclusionEntry
		{
			/// <summary>
			/// This entry works only on one particular slot identified by it's hash
			/// </summary>
			public int slotNameHash;
			/// <summary>
			/// each of the slots submeshes has an array of UInt32 that contains a boolean mask for which triangles this overlay occludes. The triangle masks are ascending (1,2,4...)
			/// </summary>
			public SubMeshOcclusion[] occlusion;
			[System.Serializable]
			public struct SubMeshOcclusion
			{
				public System.Int32[] occlusion;
			}

			public class OcclusionEntryComparer : IComparer
			{
				static OcclusionEntryComparer _instance;
				private OcclusionEntryComparer() { }
				public static OcclusionEntryComparer Instance
				{
					get
					{
						if (_instance == null)
                        {
                            _instance = new OcclusionEntryComparer();
                        }

                        return _instance;
					}
				}

				public int Compare(object x, object y)
				{
					var xo = (x as OcclusionEntry);
					var xv = (xo == null) ? (int)x : xo.slotNameHash;

					var yo = (y as OcclusionEntry);
					var yv = (yo == null) ? (int)y : yo.slotNameHash;

					if (xv < yv)
                    {
                        return -1;
                    }

                    if (xv > yv)
                    {
                        return 1;
                    }

                    return 0;
				}
			}
		}
		/// <summary>
		/// Occlusion Entries for occluding triangles, currently only supported by powertools.
		/// It is important that the OcclusionEntries be sorted by slotNameHash ascending to allow fast binary lookup
		/// </summary>
		[Tooltip("Occlusion Entries for occluding triangles, currently only supported by powertools.")]
		public OcclusionEntry[] OcclusionEntries;

		public OverlayDataAsset()
		{

		}

		public void OnAfterDeserialize()
		{
			nameHash = UMAUtils.StringToHash(overlayName);
		}

		public void OnBeforeSerialize()
		{
		}
		public Texture GetAlphaMask()
		{
			return alphaMask != null ? alphaMask : textureList[0];
		}

		public void SortOcclusion()
		{
			if (OcclusionEntries != null)
			{
				System.Array.Sort(OcclusionEntries, OcclusionEntry.OcclusionEntryComparer.Instance);
#if UNITY_EDITOR
				UnityEditor.EditorUtility.SetDirty(this);
#endif
			}
		}
	}
}
