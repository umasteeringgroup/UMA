{"MonoBehaviour":{"m_Enabled":true,"m_EditorHideFlags":0,"m_Name":"","m_EditorClassIdentifier":"","entries":[{"srpTarget":0,"UnityVersionMin":20212,"UnityVersionMax":30000,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2021.3.38f1\n//   Render Pipeline: Standard\n//   Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader \"UMA/Diffuse_Normal_Metallic\"\n{\n   Properties\n   {\n      \n\n    [BetterHeader(Material Specific)]\n    _Color (\"Main Color\", Color) = (1, 1, 1, 1)\n\t_ColorModulation (\"Color Modulation\", Range(0,2)) = 1\n\t_MetallicModulation (\"Metallic Level\", Range(0,2)) = 1\n\t_SmoothnessModulation (\"Smoothness Level\", Range(0,2)) = 1\n\t[BetterHeader(Lighting Adjustment)]\n    [Toggle]_UseHalfLambert (\"Use Half Lambert\", Float) = 0\n    _HalfLambertStrength (\"Lambert(0), HalfLambert(1)\", Range(0,16)) = 1\n    _RimLightingModulation (\"Rim Lighting Level\", Float) = 0\n\t_RimLightColor(\"Rim Light Color\", Color) = (1,1,1,1)\n\t_RimLightPower(\"Rim Light Power\", Range(0.5, 12)) = 4\n\n    [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n    [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n    _BaseMap(\"BaseMap\", 2D) = \"white\" {}\n    _BumpMap(\"_BumpMap\", 2D) = \"bump\" {}\n    _NormalStrength (\"Normal Strength\", Range(0,2)) = 1\n    _MetallicGlossMap(\"_MetallicGlossMap\", 2D) = \"black\" {}\n    _UberTile(\"Uber Tile\", Range(0,16)) = 1\n\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderType\" = \"Opaque\" \"Queue\" = \"Geometry\" }\n\n      \n      \n      Pass\n      {\n\t\t   Name \"FORWARD\"\n\t\t   Tags { \"LightMode\" = \"ForwardBase\" }\n         \n            Cull [_CullMode]\n\n\n         CGPROGRAM\n         // compile directives\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma multi_compile_fog\n         #pragma multi_compile_fwdbase\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n         // -------- variant for: <when no other keywords are defined>\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"AutoLight.cginc\"\n         #define SHADER_PASS SHADERPASS_FORWARD\n         #define _PASSFORWARD 1\n\n         \n\n\n   #define _STANDARD 1\n// If your looking in here and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us to use the same\n// texturing library they use. However, since they are not included in the standard pipeline by default, there is no\n// way to include them in and they have to be inlined, since someone could copy this shader onto another machine without\n// Better Shaders installed. Unfortunate, but I'd rather do this and have a nice library for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n#if defined(SHADER_API_GAMECORE)\n\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\t#define ASSIGN_SAMPLER(samplerName, samplerValue) samplerName = samplerValue\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define SAMPLE_DEPTH_TEXTURE(textureName, samplerName, coord2)          SAMPLE_TEXTURE2D(textureName, samplerName, coord2).r\n\t#define SAMPLE_DEPTH_TEXTURE_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod).r\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n// This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t// This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)              textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)          TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)            TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)             TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)          TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)           TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)        textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                              textureName.Load(int4(unCoord3, lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 / (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName) #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                        samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                  samplerCUBE textureName // No supoport to textureCubeArray and can't emulate with texture2DArray\n\t#define TEXTURE3D(textureName)                          sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                    sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)              TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                  samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)            TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                   samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)             TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                 SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)           TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t    // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0, bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                     ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                                texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                   ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)        ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                         ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                           SHADOW2D_SAMPLE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                         SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t// Not supported. Can't define as error because shader library is calling these functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                               half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                             half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                  half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                               ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t// Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#   define UNITY_LOOP\n#endif\n\n\n\n#define NEED_FACING 1\n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCOORD3;\n            // float4 texcoord1 : TEXCOORD4;\n            // float4 texcoord2 : TEXCOORD5;\n            // #if %TEXCOORD3REQUIREKEY%\n            // float4 texcoord3 : TEXCOORD6;\n            // #endif\n\n            // #if %SCREENPOSREQUIREKEY%\n            // float4 screenPos : TEXCOORD7;\n            // #endif\n\n            float4 lmap : TEXCOORD8;\n            #if UNITY_SHOULD_SAMPLE_SH\n               half3 sh : TEXCOORD9; // SH\n            #endif\n            #ifdef LIGHTMAP_ON\n               UNITY_LIGHTING_COORDS(10,11)\n               UNITY_FOG_COORDS(12)\n            #else\n               UNITY_FOG_COORDS(10)\n               UNITY_SHADOW_COORDS(11)\n            #endif\n\n            // #if %VERTEXCOLORREQUIREKEY%\n            // float4 vertexColor : COLOR;\n            // #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD13;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD14;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4 extraV2F2 : TEXCOORD15;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD16;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // float4 extraV2F4 : TEXCOORD17;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // float4 extraV2F5 : TEXCOORD18;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // float4 extraV2F6 : TEXCOORD19;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // float4 extraV2F7 : TEXCOORD20;\n            // #endif\n\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef UNITY_MATRIX_I_M\n\n               #define UNITY_MATRIX_I_M   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           UNITY_SETUP_INSTANCE_ID(v);\n           VertexToPixel o;\n           UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n           UNITY_TRANSFER_INSTANCE_ID(v,o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n           o.pos = UnityObjectToClipPos(v.vertex);\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // #if %SCREENPOSREQUIREKEY%\n           // o.screenPos = ComputeScreenPos(o.pos);\n           // #endif\n\n           o.worldPos = mul(GetObjectToWorldMatrix(), v.vertex).xyz;\n           o.worldNormal = UnityObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n           #ifdef DYNAMICLIGHTMAP_ON\n           o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n           #endif\n           #ifdef LIGHTMAP_ON\n           o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n           #endif\n\n           // SH/ambient and vertex lights\n           #ifndef LIGHTMAP_ON\n             #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n               o.sh = 0;\n               // Approximated illumination from non-important point lights\n               #ifdef VERTEXLIGHT_ON\n                 o.sh += Shade4PointLights (\n                   unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,\n                   unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,\n                   unity_4LightAtten0, o.worldPos, o.worldNormal);\n               #endif\n               o.sh = ShadeSHPerVertex (o.worldNormal, o.sh);\n             #endif\n           #endif // !LIGHTMAP_ON\n\n           UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader\n           #else\n             UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader\n           #endif\n\n           return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN\n         #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n         #endif\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n           ShaderData d = CreateShaderData(IN\n              #if NEED_FACING\n                 , facing\n              #endif\n           );\n           Surface l = (Surface)0;\n\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           \n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n            \n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n           // compute lighting & shadowing factor\n           UNITY_LIGHT_ATTENUATION(atten, IN, d.worldSpacePosition)\n\n           #if _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n              #else\n                 SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular = l.Specular;\n              o.Occlusion = l.Occlusion;\n              o.Smoothness = l.Smoothness;\n           #elif _BDRFLAMBERT || _BDRF3 || _SIMPLELIT\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutput o = (SurfaceOutput)0;\n              #else\n                 SurfaceOutput o;\n              #endif\n\n              o.Specular = l.Specular;\n              o.Gloss = l.Smoothness;\n              _SpecColor.rgb = l.Specular; // fucking hell Unity, wtf..\n           #else\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n              #else\n                 SurfaceOutputStandard o;\n              #endif\n              o.Smoothness = l.Smoothness;\n              o.Metallic = l.Metallic;\n              o.Occlusion = l.Occlusion;\n           #endif\n\n           o.Albedo = l.Albedo;\n           o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n           #if _WORLDSPACENORMAL\n              o.Normal = l.Normal;\n           #else\n              o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n           #endif\n\n            fixed4 c = 0;\n            // Setup lighting environment\n            UnityGI gi;\n            UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n            gi.indirect.diffuse = 0;\n            gi.indirect.specular = 0;\n            gi.light.color = _LightColor0.rgb;\n            gi.light.dir = lightDir;\n            // Call GI (lightmaps/SH/reflections) lighting function\n            UnityGIInput giInput;\n            UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n            giInput.light = gi.light;\n            giInput.worldPos = d.worldSpacePosition;\n            giInput.worldViewDir = worldViewDir;\n            giInput.atten = atten;\n            #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n               giInput.lightmapUV = IN.lmap;\n            #else\n               giInput.lightmapUV = 0.0;\n            #endif\n            #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n               giInput.ambient = IN.sh;\n            #else\n               giInput.ambient.rgb = 0.0;\n            #endif\n            giInput.probeHDR[0] = unity_SpecCube0_HDR;\n            giInput.probeHDR[1] = unity_SpecCube1_HDR;\n            #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n               giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending\n            #endif\n            #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n               giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n               giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n               giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n               giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n               giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n            #endif\n\n            \n\n            #if defined(_OVERRIDE_SHADOWMASK)\n               float4 mulColor = saturate(dot(l.ShadowMask, unity_OcclusionMaskSelector));\n               gi.light.color *= mulColor;\n               giInput.light.color *= mulColor;\n            #endif\n\n            #if _UNLIT\n              c.rgb = l.Albedo;\n              c.a = l.Alpha;\n            #elif _BDRF3 || _SIMPLELIT\n               LightingBlinnPhong_GI(o, giInput, gi);\n               #if defined(_OVERRIDE_BAKEDGI)\n                  gi.indirect.diffuse = l.DiffuseGI;\n                  gi.indirect.specular = l.SpecularGI;\n               #endif\n               c += LightingBlinnPhong (o, d.worldSpaceViewDir, gi);\n            #elif _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n               LightingStandardSpecular_GI(o, giInput, gi);\n               #if defined(_OVERRIDE_BAKEDGI)\n                  gi.indirect.diffuse = l.DiffuseGI;\n                  gi.indirect.specular = l.SpecularGI;\n               #endif\n               c += LightingStandardSpecular (o, d.worldSpaceViewDir, gi);\n            #else\n               LightingStandard_GI(o, giInput, gi);\n               #if defined(_OVERRIDE_BAKEDGI)\n                  gi.indirect.diffuse = l.DiffuseGI;\n                  gi.indirect.specular = l.SpecularGI;\n               #endif\n               c += LightingStandard (o, d.worldSpaceViewDir, gi);\n            #endif\n\n           c.rgb += o.Emission;\n\n           ChainFinalColorForward(l, d, c);\n\n           #if !DISABLEFOG\n            UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog\n           #endif\n           \n\n           return c;\n         }\n\n         ENDCG\n\n      }\n\n\n      \n\t   // ---- deferred shading pass:\n\t   Pass\n      {\n\t\t   Name \"DEFERRED\"\n\t\t   Tags { \"LightMode\" = \"Deferred\" }\n\n            Cull [_CullMode]\n\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma exclude_renderers nomrt\n         #pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n         #pragma multi_compile_prepassfinal\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n\n         #define _PASSGBUFFER 1\n\n         \n\n\n   #define _STANDARD 1\n// If your looking in here and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us to use the same\n// texturing library they use. However, since they are not included in the standard pipeline by default, there is no\n// way to include them in and they have to be inlined, since someone could copy this shader onto another machine without\n// Better Shaders installed. Unfortunate, but I'd rather do this and have a nice library for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n#if defined(SHADER_API_GAMECORE)\n\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\t#define ASSIGN_SAMPLER(samplerName, samplerValue) samplerName = samplerValue\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define SAMPLE_DEPTH_TEXTURE(textureName, samplerName, coord2)          SAMPLE_TEXTURE2D(textureName, samplerName, coord2).r\n\t#define SAMPLE_DEPTH_TEXTURE_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod).r\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n// This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t// This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)              textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)          TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)            TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)             TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)          TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)           TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)        textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                              textureName.Load(int4(unCoord3, lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 / (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName) #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                        samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                  samplerCUBE textureName // No supoport to textureCubeArray and can't emulate with texture2DArray\n\t#define TEXTURE3D(textureName)                          sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                    sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)              TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                  samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)            TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                   samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)             TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                 SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)           TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t    // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0, bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                     ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                                texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                   ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)        ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                         ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                           SHADOW2D_SAMPLE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                         SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t// Not supported. Can't define as error because shader library is calling these functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                               half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                             half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                  half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                               ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t// Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#   define UNITY_LOOP\n#endif\n\n\n\n#define NEED_FACING 1\n\n         \n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);       // must be named pos because Unity does stupid macro stuff\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCOORD3;\n            // float4 texcoord1 : TEXCOORD4;\n            // float4 texcoord2 : TEXCOORD5;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // float4 texcoord3 : TEXCOORD6;\n            // #endif\n\n            // #if %SCREENPOSREQUIREKEY%\n            // float4 screenPos : TEXCOORD7;\n            // #endif\n\n            #ifndef DIRLIGHTMAP_OFF\n              float3 viewDir : TEXCOORD8;\n            #endif\n            float4 lmap : TEXCOORD9;\n            #ifndef LIGHTMAP_ON\n              #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n                half3 sh : TEXCOORD10; // SH\n              #endif\n            #else\n              #ifdef DIRLIGHTMAP_OFF\n                float4 lmapFadePos : TEXCOORD11;\n              #endif\n            #endif\n\n            \n            // #if %VERTEXCOLORREQUIREKEY%\n            // float4 vertexColor : COLOR;\n            // #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD12;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD13;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4 extraV2F2 : TEXCOORD14;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD15;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // float4 extraV2F4 : TEXCOORD16;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // float4 extraV2F5 : TEXCOORD17;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // float4 extraV2F6 : TEXCOORD18;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // float4 extraV2F7 : TEXCOORD19;\n            // #endif\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef UNITY_MATRIX_I_M\n\n               #define UNITY_MATRIX_I_M   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n            UNITY_SETUP_INSTANCE_ID(v);\n            VertexToPixel o;\n            UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n            UNITY_TRANSFER_INSTANCE_ID(v,o);\n            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.pos = UnityObjectToClipPos(v.vertex);\n             o.texcoord0 = v.texcoord0;\n            // o.texcoord1 = v.texcoord1;\n            // o.texcoord2 = v.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // o.texcoord3 = v.texcoord3;\n            // #endif\n\n            // #if %VERTEXCOLORREQUIREKEY%\n            // o.vertexColor = v.vertexColor;\n            // #endif\n\n            // #if %SCREENPOSREQUIREKEY%\n            // o.screenPos = ComputeScreenPos(o.pos);\n            // #endif\n\n            o.worldPos = mul(GetObjectToWorldMatrix(), v.vertex).xyz;\n            o.worldNormal = UnityObjectToWorldNormal(v.normal);\n            o.worldTangent = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n            float3 viewDirForLight = UnityWorldSpaceViewDir(o.worldPos);\n            #ifndef DIRLIGHTMAP_OFF\n               float3 worldBinormal = cross(o.worldNormal, o.worldTangent.xyz);\n               o.viewDir.x = dot(viewDirForLight, o.worldTangent.xyz);\n               o.viewDir.y = dot(viewDirForLight, worldBinormal);\n               o.viewDir.z = dot(viewDirForLight, o.worldNormal);\n            #endif\n            #ifdef DYNAMICLIGHTMAP_ON\n               o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n            #else\n               o.lmap.zw = 0;\n            #endif\n            #ifdef LIGHTMAP_ON\n               o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n               #ifdef DIRLIGHTMAP_OFF\n                  o.lmapFadePos.xyz = (mul(GetObjectToWorldMatrix(), v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;\n                  o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);\n               #endif\n            #else\n               o.lmap.xy = 0;\n               #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n                  o.sh = 0;\n                  o.sh = ShadeSHPerVertex (o.worldNormal, o.sh);\n               #endif\n            #endif\n\n            return o;\n         }\n\n         \n\n         #ifdef LIGHTMAP_ON\n         float4 unity_LightmapFade;\n         #endif\n         fixed4 unity_Ambient;\n\n         \n\n         // fragment shader\n         void Frag (VertexToPixel IN,\n             out half4 outGBuffer0 : SV_Target0,\n             out half4 outGBuffer1 : SV_Target1,\n             out half4 outGBuffer2 : SV_Target2,\n             out half4 outEmission : SV_Target3\n         #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n             , out half4 outShadowMask : SV_Target4\n         #endif\n         #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n         #endif\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n         #endif\n         )\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n           ShaderData d = CreateShaderData(IN\n              #if NEED_FACING\n                 , facing\n              #endif\n           );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n           \n\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n           #if _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n              #else\n                 SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular = l.Specular;\n              o.Occlusion = l.Occlusion;\n              o.Smoothness = l.Smoothness;\n           #elif _BDRFLAMBERT || _BDRF3 || _SIMPLELIT\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutput o = (SurfaceOutput)0;\n              #else\n                 SurfaceOutput o;\n              #endif\n\n              o.Specular = l.SpecularPower;\n              o.Gloss = l.Smoothness;\n              _SpecColor.rgb = l.Specular; // fucking hell Unity, wtf..\n           #else\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n              #else\n                 SurfaceOutputStandard o;\n              #endif\n              o.Smoothness = l.Smoothness;\n              o.Metallic = l.Metallic;\n              o.Occlusion = l.Occlusion;\n           #endif\n\n\n           \n           o.Albedo = l.Albedo;\n           o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n\n           #if _WORLDSPACENORMAL\n              o.Normal = l.Normal;\n           #else\n              o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n           #endif\n\n\n           half atten = 1;\n\n           // Setup lighting environment\n           UnityGI gi;\n           UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n           gi.indirect.diffuse = 0;\n           gi.indirect.specular = 0;\n           gi.light.color = 0;\n           gi.light.dir = half3(0,1,0);\n           // Call GI (lightmaps/SH/reflections) lighting function\n           UnityGIInput giInput;\n           UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);\n           giInput.light = gi.light;\n           giInput.worldPos = d.worldSpacePosition;\n           giInput.worldViewDir = worldViewDir;\n           giInput.atten = atten;\n           #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)\n             giInput.lightmapUV = IN.lmap;\n           #else\n             giInput.lightmapUV = 0.0;\n           #endif\n           #if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL\n             giInput.ambient = IN.sh;\n           #else\n             giInput.ambient.rgb = 0.0;\n           #endif\n           giInput.probeHDR[0] = unity_SpecCube0_HDR;\n           giInput.probeHDR[1] = unity_SpecCube1_HDR;\n           #if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)\n             giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending\n           #endif\n           #ifdef UNITY_SPECCUBE_BOX_PROJECTION\n             giInput.boxMax[0] = unity_SpecCube0_BoxMax;\n             giInput.probePosition[0] = unity_SpecCube0_ProbePosition;\n             giInput.boxMax[1] = unity_SpecCube1_BoxMax;\n             giInput.boxMin[1] = unity_SpecCube1_BoxMin;\n             giInput.probePosition[1] = unity_SpecCube1_ProbePosition;\n           #endif\n\n          \n\n           #if _BDRF3 || _SIMPLELIT\n              \n              LightingBlinnPhong_GI(o, giInput, gi);\n              #if defined(_OVERRIDE_BAKEDGI)\n               gi.indirect.diffuse = l.DiffuseGI;\n               gi.indirect.specular = l.SpecularGI;\n              #endif\n\n              outEmission = LightingBlinnPhong_Deferred(o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n              #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n                outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, d.worldSpacePosition);\n              #endif\n              #ifndef UNITY_HDR_ON\n              outEmission.rgb = exp2(-outEmission.rgb);\n              #endif\n           #elif _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n              LightingStandardSpecular_GI(o, giInput, gi);\n              #if defined(_OVERRIDE_BAKEDGI)\n               gi.indirect.diffuse = l.DiffuseGI;\n               gi.indirect.specular = l.SpecularGI;\n              #endif\n              // call lighting function to output g-buffer\n              outEmission = LightingStandardSpecular_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n              #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n                outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, d.worldSpacePosition);\n              #endif\n              #ifndef UNITY_HDR_ON\n              outEmission.rgb = exp2(-outEmission.rgb);\n              #endif\n           #else\n              LightingStandard_GI(o, giInput, gi);\n              #if defined(_OVERRIDE_BAKEDGI)\n               gi.indirect.diffuse = l.DiffuseGI;\n               gi.indirect.specular = l.SpecularGI;\n              #endif\n              // call lighting function to output g-buffer\n              outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);\n              #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n                outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, d.worldSpacePosition);\n              #endif\n              #ifndef UNITY_HDR_ON\n              outEmission.rgb = exp2(-outEmission.rgb);\n              #endif\n           #endif\n\n            #if defined(_OVERRIDE_SHADOWMASK) && defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n               float4 mulColor = saturate(dot(l.ShadowMask, unity_OcclusionMaskSelector));\n               outShadowMask = mulColor;\n            #endif\n            \n           #if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)\n               ChainFinalGBufferStandard(l, d, outGBuffer0, outGBuffer1, outGBuffer2, outEmission, outShadowMask);\n           #else\n               half4 outShadowMask = 0;\n               ChainFinalGBufferStandard(l, d, outGBuffer0, outGBuffer1, outGBuffer2, outEmission, outShadowMask);\n           #endif\n\n           \n         }\n\n\n\n\n         ENDCG\n\n      }\n\n\n      \n\n\t   // ---- forward rendering additive lights pass:\n\t   Pass\n      {\n\t\t   Name \"FORWARD\"\n\t\t   Tags { \"LightMode\" = \"ForwardAdd\" }\n\t\t   ZWrite Off Blend One One\n         \n            Cull [_CullMode]\n\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma multi_compile_fog\n         #pragma skip_variants INSTANCING_ON\n         #pragma multi_compile_fwdadd_fullshadows\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"AutoLight.cginc\"\n\n         \n\n         #define _PASSFORWARD 1\n         #define _PASSFORWARDADD 1\n\n         \n\n\n   #define _STANDARD 1\n// If your looking in here and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us to use the same\n// texturing library they use. However, since they are not included in the standard pipeline by default, there is no\n// way to include them in and they have to be inlined, since someone could copy this shader onto another machine without\n// Better Shaders installed. Unfortunate, but I'd rather do this and have a nice library for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n#if defined(SHADER_API_GAMECORE)\n\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\t#define ASSIGN_SAMPLER(samplerName, samplerValue) samplerName = samplerValue\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define SAMPLE_DEPTH_TEXTURE(textureName, samplerName, coord2)          SAMPLE_TEXTURE2D(textureName, samplerName, coord2).r\n\t#define SAMPLE_DEPTH_TEXTURE_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod).r\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n// This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t// This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)              textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)          TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)            TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)             TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)          TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)           TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)        textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                              textureName.Load(int4(unCoord3, lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 / (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName) #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                        samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                  samplerCUBE textureName // No supoport to textureCubeArray and can't emulate with texture2DArray\n\t#define TEXTURE3D(textureName)                          sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                    sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)              TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                  samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)            TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                   samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)             TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                 SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)           TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t    // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0, bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                     ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                                texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                   ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)        ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                         ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                           SHADOW2D_SAMPLE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                         SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t// Not supported. Can't define as error because shader library is calling these functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                               half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                             half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                  half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                               ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t// Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#   define UNITY_LOOP\n#endif\n\n\n\n#define NEED_FACING 1\n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);       // must be named pos because Unity does stupid macro stuff\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCOORD3;\n            // float4 texcoord1 : TEXCOORD4;\n            // float4 texcoord2 : TEXCOORD5;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // float4 texcoord3 : TEXCOORD6;\n            // #endif\n            \n            // #if %SCREENPOSREQUIREKEY%\n            // float4 screenPos : TEXCOORD7;\n            // #endif\n\n            UNITY_LIGHTING_COORDS(8,9)\n            UNITY_FOG_COORDS(10)\n\n            \n            // #if %VERTEXCOLORREQUIREKEY%\n            // float4 vertexColor : COLOR;\n            // #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD11;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD12;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4 extraV2F2 : TEXCOORD13;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD14;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // float4 extraV2F4 : TEXCOORD15;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // float4 extraV2F5 : TEXCOORD16;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // float4 extraV2F6 : TEXCOORD17;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // float4 extraV2F7 : TEXCOORD18;\n            // #endif\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef UNITY_MATRIX_I_M\n\n               #define UNITY_MATRIX_I_M   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n         \n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           UNITY_SETUP_INSTANCE_ID(v);\n           VertexToPixel o;\n           UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n           UNITY_TRANSFER_INSTANCE_ID(v,o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n           o.pos = UnityObjectToClipPos(v.vertex);\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // #if %SCREENPOSREQUIREKEY%\n           // o.screenPos = ComputeScreenPos(o.pos);\n           // #endif\n\n           o.worldPos = mul(GetObjectToWorldMatrix(), v.vertex).xyz;\n           o.worldNormal = UnityObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n           UNITY_TRANSFER_LIGHTING(o, v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader\n           UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader\n\n           return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN\n         #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n         #endif\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n\n\n           ShaderData d = CreateShaderData(IN\n              #if NEED_FACING\n                 , facing\n              #endif\n           );\n           Surface l = (Surface)0;\n\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(d.worldSpacePosition));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n           float3 worldViewDir = normalize(UnityWorldSpaceViewDir(d.worldSpacePosition));\n\n           #if _USESPECULAR || _USESPECULARWORKFLOW || _SPECULARFROMMETALLIC\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandardSpecular o = (SurfaceOutputStandardSpecular)0;\n              #else\n                 SurfaceOutputStandardSpecular o;\n              #endif\n              o.Specular = l.Specular;\n              o.Occlusion = l.Occlusion;\n              o.Smoothness = l.Smoothness;\n           #elif _BDRFLAMBERT || _BDRF3 || _SIMPLELIT\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutput o = (SurfaceOutput)0;\n              #else\n                 SurfaceOutput o;\n              #endif\n\n              o.Specular = l.SpecularPower;\n              o.Gloss = l.Smoothness;\n              _SpecColor.rgb = l.Specular; // fucking hell Unity, wtf..\n           #else\n              #ifdef UNITY_COMPILER_HLSL\n                 SurfaceOutputStandard o = (SurfaceOutputStandard)0;\n              #else\n                 SurfaceOutputStandard o;\n              #endif\n              o.Smoothness = l.Smoothness;\n              o.Metallic = l.Metallic;\n              o.Occlusion = l.Occlusion;\n           #endif\n\n   \n           o.Albedo = l.Albedo;\n           o.Emission = l.Emission;\n           o.Alpha = l.Alpha;\n\n           #if _WORLDSPACENORMAL\n              o.Normal = l.Normal;\n           #else\n              o.Normal = normalize(TangentToWorldSpace(d, l.Normal));\n           #endif\n\n\n\n           UNITY_LIGHT_ATTENUATION(atten, IN, d.worldSpacePosition)\n           half4 c = 0;\n\n           // Setup lighting environment\n           UnityGI gi;\n           UNITY_INITIALIZE_OUTPUT(UnityGI, gi);\n           gi.indirect.diffuse = 0;\n           gi.indirect.specular = 0;\n           gi.light.color = _LightColor0.rgb;\n           gi.light.dir = lightDir;\n           gi.light.color *= atten;\n\n           #if defined(_OVERRIDE_SHADOWMASK)\n               float4 mulColor = saturate(dot(l.ShadowMask, unity_OcclusionMaskSelector));\n               gi.light.color *= mulColor;\n            #endif\n\n           #if _USESPECULAR\n              c += LightingStandardSpecular (o, worldViewDir, gi);\n           #elif _BDRF3 || _SIMPLELIT\n              c += LightingBlinnPhong (o, d.worldSpaceViewDir, gi);\n           #else\n              c += LightingStandard (o, worldViewDir, gi);\n           #endif\n           \n\n           ChainFinalColorForward(l, d, c);\n\n           #if !DISABLEFOG\n            UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog\n           #endif\n           #if !_ALPHABLEND_ON\n              UNITY_OPAQUE_ALPHA(c.a);\n           #endif\n           \n           return c;\n         }\n\n         ENDCG\n\n      }\n\n      \n\t   Pass {\n\t\t   Name \"ShadowCaster\"\n\t\t   Tags { \"LightMode\" = \"ShadowCaster\" }\n\t\t   ZWrite On ZTest LEqual\n\n            Cull [_CullMode]\n\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n         #pragma multi_compile_shadowcaster\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n\n         #define _PASSSHADOW 1\n\n         \n\n\n   #define _STANDARD 1\n// If your looking in here and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us to use the same\n// texturing library they use. However, since they are not included in the standard pipeline by default, there is no\n// way to include them in and they have to be inlined, since someone could copy this shader onto another machine without\n// Better Shaders installed. Unfortunate, but I'd rather do this and have a nice library for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n#if defined(SHADER_API_GAMECORE)\n\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\t#define ASSIGN_SAMPLER(samplerName, samplerValue) samplerName = samplerValue\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define SAMPLE_DEPTH_TEXTURE(textureName, samplerName, coord2)          SAMPLE_TEXTURE2D(textureName, samplerName, coord2).r\n\t#define SAMPLE_DEPTH_TEXTURE_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod).r\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n// This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t// This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)              textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)          TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)            TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)             TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)          TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)           TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)        textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                              textureName.Load(int4(unCoord3, lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 / (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName) #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                        samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                  samplerCUBE textureName // No supoport to textureCubeArray and can't emulate with texture2DArray\n\t#define TEXTURE3D(textureName)                          sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                    sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)              TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                  samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)            TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                   samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)             TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                 SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)           TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t    // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0, bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                     ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                                texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                   ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)        ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                         ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                           SHADOW2D_SAMPLE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                         SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t// Not supported. Can't define as error because shader library is calling these functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                               half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                             half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                  half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                               ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t// Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#   define UNITY_LOOP\n#endif\n\n\n\n#define NEED_FACING 1\n\n         \n\n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            V2F_SHADOW_CASTER; // may declare TEXCOORD0 for the wonderfully named .vec\n            float3 worldPos : TEXCOORD1;\n            float3 worldNormal : TEXCOORD2;\n            float4 worldTangent : TEXCOORD3;\n             float4 texcoord0 : TEXCOORD4;\n            // float4 texcoord1 : TEXCOORD5;\n            // float4 texcoord2 : TEXCOORD6;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // float4 texcoord3 : TEXCOORD7;\n            // #endif\n\n            // #if %SCREENPOSREQUIREKEY%\n            // float4 screenPos : TEXCOORD8;\n            // #endif\n            \n            // #if %VERTEXCOLORREQUIREKEY%\n            // float4 vertexColor : COLOR;\n            // #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD9;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD10;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4 extraV2F2 : TEXCOORD11;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD12;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // float4 extraV2F4 : TEXCOORD13;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // float4 extraV2F5 : TEXCOORD14;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // float4 extraV2F6 : TEXCOORD15;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // float4 extraV2F7 : TEXCOORD16;\n            // #endif\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef UNITY_MATRIX_I_M\n\n               #define UNITY_MATRIX_I_M   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n            UNITY_SETUP_INSTANCE_ID(v);\n            VertexToPixel o;\n            UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n            UNITY_TRANSFER_INSTANCE_ID(v,o);\n            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n             o.texcoord0 = v.texcoord0;\n            // o.texcoord1 = v.texcoord1;\n            // o.texcoord2 = v.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // o.texcoord3 = v.texcoord3;\n            // #endif\n\n            // #if %VERTEXCOLORREQUIREKEY%\n            // o.vertexColor = v.vertexColor;\n            // #endif\n\n            \n\n            o.worldPos = mul(GetObjectToWorldMatrix(), v.vertex).xyz;\n            o.worldNormal = UnityObjectToWorldNormal(v.normal);\n            o.worldTangent = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n\n            // sets o.pos, so do screenpos after.\n            TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)\n\n            // #if %SCREENPOSREQUIREKEY%\n            // o.screenPos = ComputeScreenPos(o.pos);\n            // #endif\n\n            return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN\n         #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n         #endif\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           // prepare and unpack data\n\n           #ifdef FOG_COMBINED_WITH_TSPACE\n             UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n           #elif defined FOG_COMBINED_WITH_WORLD_POS\n             UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n           #else\n             UNITY_EXTRACT_FOG(IN);\n           #endif\n\n           #ifndef USING_DIRECTIONAL_LIGHT\n             fixed3 lightDir = normalize(UnityWorldSpaceLightDir(IN.worldPos));\n           #else\n             fixed3 lightDir = _WorldSpaceLightPos0.xyz;\n           #endif\n\n           \n\n           ShaderData d = CreateShaderData(IN\n              #if NEED_FACING\n                 , facing\n              #endif\n           );\n\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n           SHADOW_CASTER_FRAGMENT(IN)\n         }\n\n\n         ENDCG\n\n      }\n\n      \n\t   // ---- meta information extraction pass:\n\t   Pass\n      {\n\t\t   Name \"Meta\"\n\t\t   Tags { \"LightMode\" = \"Meta\" }\n\t\t   Cull Off\n\n            Cull [_CullMode]\n\n\n         CGPROGRAM\n\n            #pragma vertex Vert\n   #pragma fragment Frag\n\n         // compile directives\n         #pragma target 3.0\n         #pragma multi_compile_instancing\n         #pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2\n         #pragma shader_feature EDITOR_VISUALIZATION\n\n         #include \"HLSLSupport.cginc\"\n         #define UNITY_INSTANCED_LOD_FADE\n         #define UNITY_INSTANCED_SH\n         #define UNITY_INSTANCED_LIGHTMAPSTS\n         #include \"UnityShaderVariables.cginc\"\n         #include \"UnityShaderUtilities.cginc\"\n\n         #include \"UnityCG.cginc\"\n         #include \"Lighting.cginc\"\n         #include \"UnityPBSLighting.cginc\"\n         #include \"UnityMetaPass.cginc\"\n\n         #define _PASSMETA 1\n\n         \n\n\n   #define _STANDARD 1\n// If your looking in here and thinking WTF, yeah, I know. These are taken from the SRPs, to allow us to use the same\n// texturing library they use. However, since they are not included in the standard pipeline by default, there is no\n// way to include them in and they have to be inlined, since someone could copy this shader onto another machine without\n// Better Shaders installed. Unfortunate, but I'd rather do this and have a nice library for texture sampling instead\n// of the patchy one Unity provides being inlined/emulated in HDRP/URP. Strangely, PSSL and XBoxOne libraries are not\n// included in the standard SRP code, but they are in tons of Unity own projects on the web, so I grabbed them from there.\n\n#if defined(SHADER_API_GAMECORE)\n\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\t#define ASSIGN_SAMPLER(samplerName, samplerValue) samplerName = samplerValue\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               PLATFORM_SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      PLATFORM_SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    PLATFORM_SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              PLATFORM_SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  PLATFORM_SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         PLATFORM_SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       PLATFORM_SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) PLATFORM_SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             PLATFORM_SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    PLATFORM_SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  PLATFORM_SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                PLATFORM_SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     PLATFORM_SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               PLATFORM_SAMPLE_TEXTURE3D(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      PLATFORM_SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define SAMPLE_DEPTH_TEXTURE(textureName, samplerName, coord2)          SAMPLE_TEXTURE2D(textureName, samplerName, coord2).r\n\t#define SAMPLE_DEPTH_TEXTURE_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod).r\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_XBOXONE)\n\t\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n#elif defined(SHADER_API_PSSL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.GetLOD(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RW_Texture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RW_Texture2D_Array<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RW_Texture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n\n\n#elif defined(SHADER_API_D3D11)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)        TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)          TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)           TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_METAL)\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_VULKAN)\n// This file assume SHADER_API_VULKAN is defined\n\t// TODO: This is a straight copy from D3D11.hlsl. Go through all this stuff and adjust where needed.\n\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                   textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                          textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_SWITCH)\n\t// This file assume SHADER_API_SWITCH is defined\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)          Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)              TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)        TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)          Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)    Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)        TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)  TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)          Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)           Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)     Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)         TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)   TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)           Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)         TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)   TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)       TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName) TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)       RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName) RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)       RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                  SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)              SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, dpdx, dpdy)              textureName.SampleGrad(samplerName, coord2, dpdx, dpdy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)       textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)     textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                               textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                      textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                    textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)       textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                  textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)     textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod) textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)              textureName.Load(int4(unCoord3, lod))\n\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)   textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)              textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index) textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)           textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)          textureName.GatherAlpha(samplerName, coord2)\n\n#elif defined(SHADER_API_GLCORE)\n\n\t// OpenGL 4.1 SM 5.0 https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 46)\n\t#define OPENGL4_1_SM5 1\n\t#else\n\t#define OPENGL4_1_SM5 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_FLOAT(textureName)          TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_FLOAT(textureName)            TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_HALF(textureName)             TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_HALF(textureName)           TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TEXTURECUBE_ARRAY(textureName)\n\t#define TEXTURE3D_HALF(textureName)             TEXTURE3D(textureName)\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, bias) ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                   textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                          textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                 textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                      textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)    textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)             textureName.Load(int4(unCoord2, index, lod))\n\n\t#if OPENGL4_1_SM5\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#endif\n\n\n\t#elif defined(SHADER_API_GLES3)\n\n\t// GLES 3.1 + AEP shader feature https://docs.unity3d.com/Manual/SL-ShaderCompileTargets.html\n\t#if (SHADER_TARGET >= 40)\n\t#define GLES3_1_AEP 1\n\t#else\n\t#define GLES3_1_AEP 0\n\t#endif\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) textureName.CalculateLevelOfDetail(samplerName, coord2)\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                  Texture2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)            Texture2DArray textureName\n\t#define TEXTURECUBE(textureName)                TextureCube textureName\n\t#define TEXTURECUBE_ARRAY(textureName)          TextureCubeArray textureName\n\t#define TEXTURE3D(textureName)                  Texture3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)            Texture2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)      Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_FLOAT(textureName)          TextureCube_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)    TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_FLOAT(textureName)            Texture3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)             Texture2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)       Texture2DArray textureName    // no support to _float on Array, it's being added\n\t#define TEXTURECUBE_HALF(textureName)           TextureCube_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)     TextureCubeArray textureName  // no support to _float on Array, it's being added\n\t#define TEXTURE3D_HALF(textureName)             Texture3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)           TEXTURE2D(textureName)\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)     TEXTURE2D_ARRAY(textureName)\n\t#define TEXTURECUBE_SHADOW(textureName)         TEXTURECUBE(textureName)\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)   TEXTURECUBE_ARRAY(textureName)\n\n\t#if GLES3_1_AEP\n\t#define RW_TEXTURE2D(type, textureName)         RWTexture2D<type> textureName\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   RWTexture2DArray<type> textureName\n\t#define RW_TEXTURE3D(type, textureName)         RWTexture3D<type> textureName\n\t#else\n\t#define RW_TEXTURE2D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)   ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureName)         ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\t#endif\n\n\t#define SAMPLER(samplerName)                    SamplerState samplerName\n\t#define SAMPLER_CMP(samplerName)                SamplerComparisonState samplerName\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                 TEXTURE2D(textureName),         SAMPLER(samplerName)\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)           TEXTURE2D_ARRAY(textureName),   SAMPLER(samplerName)\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)               TEXTURECUBE(textureName),       SAMPLER(samplerName)\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)         TEXTURECUBE_ARRAY(textureName), SAMPLER(samplerName)\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                 TEXTURE3D(textureName),         SAMPLER(samplerName)\n\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)          TEXTURE2D(textureName),         SAMPLER_CMP(samplerName)\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)    TEXTURE2D_ARRAY(textureName),   SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)        TEXTURECUBE(textureName),       SAMPLER_CMP(samplerName)\n\t#define TEXTURECUBE_ARRAY_SHADOW_PARAM(textureName, samplerName)  TEXTURECUBE_ARRAY(textureName), SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)                textureName, samplerName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)          textureName, samplerName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)              textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)        textureName, samplerName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)                textureName, samplerName\n\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)         textureName, samplerName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)   textureName, samplerName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)       textureName, samplerName\n\t#define TEXTURECUBE_ARRAY_SHADOW_ARGS(textureName, samplerName) textureName, samplerName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2)                               textureName.Sample(samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod)                      textureName.SampleLevel(samplerName, coord2, lod)\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                    textureName.SampleBias(samplerName, coord2, bias)\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                textureName.SampleGrad(samplerName, coord2, ddx, ddy)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                  textureName.Sample(samplerName, float3(coord2, index))\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)         textureName.SampleLevel(samplerName, float3(coord2, index), lod)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)       textureName.SampleBias(samplerName, float3(coord2, index), bias)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy) textureName.SampleGrad(samplerName, float3(coord2, index), dpdx, dpdy)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                             textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                    textureName.SampleLevel(samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                  textureName.SampleBias(samplerName, coord3, bias)\n\n\t#ifdef UNITY_NO_CUBEMAP_ARRAY\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#else\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)           textureName.Sample(samplerName, float4(coord3, index))\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)  textureName.SampleLevel(samplerName, float4(coord3, index), lod)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)textureName.SampleBias(samplerName, float4(coord3, index), bias)\n\t#endif\n\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                          textureName.Sample(samplerName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                 textureName.SampleLevel(samplerName, coord3, lod)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                   textureName.SampleCmpLevelZero(samplerName, (coord3).xy, (coord3).z)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)      textureName.SampleCmpLevelZero(samplerName, float3((coord3).xy, index), (coord3).z)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                 textureName.SampleCmpLevelZero(samplerName, (coord4).xyz, (coord4).w)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)    textureName.SampleCmpLevelZero(samplerName, float4((coord4).xyz, index), (coord4).w)\n\n\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                       textureName.Load(int3(unCoord2, 0))\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                              textureName.Load(int3(unCoord2, lod))\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                     textureName.Load(unCoord2, sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                          textureName.Load(int4(unCoord2, index, 0))\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)        textureName.Load(int3(unCoord2, index), sampleIndex)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                 textureName.Load(int4(unCoord2, index, lod))\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                       textureName.Load(int4(unCoord3, 0))\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                              textureName.Load(int4(unCoord3, lod))\n\n\t#if GLES3_1_AEP\n\t#define PLATFORM_SUPPORT_GATHER\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  textureName.Gather(samplerName, coord2)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     textureName.Gather(samplerName, float3(coord2, index))\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                textureName.Gather(samplerName, coord3)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   textureName.Gather(samplerName, float4(coord3, index))\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              textureName.GatherRed(samplerName, coord2)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherGreen(samplerName, coord2)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             textureName.GatherBlue(samplerName, coord2)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            textureName.GatherAlpha(samplerName, coord2)\n\t#else\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\t#endif\n\n\n#elif defined(SHADER_API_GLES)\n\n\n\t#define uint int\n\n\t#define rcp(x) 1.0 / (x)\n\t#define ddx_fine ddx\n\t#define ddy_fine ddy\n\t#define asfloat\n\t#define asuint(x) asint(x)\n\t#define f32tof16\n\t#define f16tof32\n\n\t#define ERROR_ON_UNSUPPORTED_FUNCTION(funcName) #error #funcName is not supported on GLES 2.0\n\n\t// Initialize arbitrary structure with zero values.\n\t// Do not exist on some platform, in this case we need to have a standard name that call a function that will initialize all parameters to 0\n\t#define ZERO_INITIALIZE(type, name) name = (type)0;\n\t#define ZERO_INITIALIZE_ARRAY(type, name, arraySize) { for (int arrayIndex = 0; arrayIndex < arraySize; arrayIndex++) { name[arrayIndex] = (type)0; } }\n\n\n\t// Texture util abstraction\n\n\t#define CALCULATE_TEXTURE2D_LOD(textureName, samplerName, coord2) #error calculate Level of Detail not supported in GLES2\n\n\t// Texture abstraction\n\n\t#define TEXTURE2D(textureName)                          sampler2D textureName\n\t#define TEXTURE2D_ARRAY(textureName)                    samplerCUBE textureName // No support to texture2DArray\n\t#define TEXTURECUBE(textureName)                        samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY(textureName)                  samplerCUBE textureName // No supoport to textureCubeArray and can't emulate with texture2DArray\n\t#define TEXTURE3D(textureName)                          sampler3D textureName\n\n\t#define TEXTURE2D_FLOAT(textureName)                    sampler2D_float textureName\n\t#define TEXTURE2D_ARRAY_FLOAT(textureName)              TEXTURECUBE_FLOAT(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_FLOAT(textureName)                  samplerCUBE_float textureName\n\t#define TEXTURECUBE_ARRAY_FLOAT(textureName)            TEXTURECUBE_FLOAT(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_FLOAT(textureName)                    sampler3D_float textureName\n\n\t#define TEXTURE2D_HALF(textureName)                     sampler2D_half textureName\n\t#define TEXTURE2D_ARRAY_HALF(textureName)               TEXTURECUBE_HALF(textureName) // No support to texture2DArray\n\t#define TEXTURECUBE_HALF(textureName)                   samplerCUBE_half textureName\n\t#define TEXTURECUBE_ARRAY_HALF(textureName)             TEXTURECUBE_HALF(textureName) // No support to textureCubeArray\n\t#define TEXTURE3D_HALF(textureName)                     sampler3D_half textureName\n\n\t#define TEXTURE2D_SHADOW(textureName)                   SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW(textureName)             TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\t#define TEXTURECUBE_SHADOW(textureName)                 SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_ARRAY_SHADOW(textureName)           TEXTURECUBE_SHADOW(textureName) // No support to texture array\n\n\t#define RW_TEXTURE2D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2D)\n\t#define RW_TEXTURE2D_ARRAY(type, textureName)           ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture2DArray)\n\t#define RW_TEXTURE3D(type, textureNam)                  ERROR_ON_UNSUPPORTED_FUNCTION(RWTexture3D)\n\n\t#define SAMPLER(samplerName)\n\t#define SAMPLER_CMP(samplerName)\n\n\t#define TEXTURE2D_PARAM(textureName, samplerName)                sampler2D textureName\n\t#define TEXTURE2D_ARRAY_PARAM(textureName, samplerName)          samplerCUBE textureName\n\t#define TEXTURECUBE_PARAM(textureName, samplerName)              samplerCUBE textureName\n\t#define TEXTURECUBE_ARRAY_PARAM(textureName, samplerName)        samplerCUBE textureName\n\t#define TEXTURE3D_PARAM(textureName, samplerName)                sampler3D textureName\n\t#define TEXTURE2D_SHADOW_PARAM(textureName, samplerName)         SHADOW2D_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_PARAM(textureName, samplerName)   SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\t#define TEXTURECUBE_SHADOW_PARAM(textureName, samplerName)       SHADOWCUBE_TEXTURE_AND_SAMPLER textureName\n\n\t#define TEXTURE2D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_ARRAY_ARGS(textureName, samplerName)         textureName\n\t#define TEXTURECUBE_ARGS(textureName, samplerName)             textureName\n\t#define TEXTURECUBE_ARRAY_ARGS(textureName, samplerName)       textureName\n\t#define TEXTURE3D_ARGS(textureName, samplerName)               textureName\n\t#define TEXTURE2D_SHADOW_ARGS(textureName, samplerName)        textureName\n\t#define TEXTURE2D_ARRAY_SHADOW_ARGS(textureName, samplerName)  textureName\n\t#define TEXTURECUBE_SHADOW_ARGS(textureName, samplerName)      textureName\n\n\t#define SAMPLE_TEXTURE2D(textureName, samplerName, coord2) tex2D(textureName, coord2)\n\n\t#if (SHADER_TARGET >= 30)\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) tex2Dlod(textureName, float4(coord2, 0, lod))\n\t#else\n\t    // No lod support. Very poor approximation with bias.\n\t    #define SAMPLE_TEXTURE2D_LOD(textureName, samplerName, coord2, lod) SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, lod)\n\t#endif\n\n\t#define SAMPLE_TEXTURE2D_BIAS(textureName, samplerName, coord2, bias)                       tex2Dbias(textureName, float4(coord2, 0, bias))\n\t#define SAMPLE_TEXTURE2D_GRAD(textureName, samplerName, coord2, ddx, ddy)                   SAMPLE_TEXTURE2D(textureName, samplerName, coord2)\n\t#define SAMPLE_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)                     ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY)\n\t#define SAMPLE_TEXTURE2D_ARRAY_LOD(textureName, samplerName, coord2, index, lod)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_LOD)\n\t#define SAMPLE_TEXTURE2D_ARRAY_BIAS(textureName, samplerName, coord2, index, bias)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE2D_ARRAY_GRAD(textureName, samplerName, coord2, index, dpdx, dpdy)    ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_GRAD)\n\t#define SAMPLE_TEXTURECUBE(textureName, samplerName, coord3)                                texCUBE(textureName, coord3)\n\t// No lod support. Very poor approximation with bias.\n\t#define SAMPLE_TEXTURECUBE_LOD(textureName, samplerName, coord3, lod)                       SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, lod)\n\t#define SAMPLE_TEXTURECUBE_BIAS(textureName, samplerName, coord3, bias)                     texCUBEbias(textureName, float4(coord3, bias))\n\t#define SAMPLE_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)                   ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_LOD(textureName, samplerName, coord3, index, lod)          ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_LOD)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_BIAS(textureName, samplerName, coord3, index, bias)        ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_BIAS)\n\t#define SAMPLE_TEXTURE3D(textureName, samplerName, coord3)                                  tex3D(textureName, coord3)\n\t#define SAMPLE_TEXTURE3D_LOD(textureName, samplerName, coord3, lod)                         ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE3D_LOD)\n\n\t#define SAMPLE_TEXTURE2D_SHADOW(textureName, samplerName, coord3)                           SHADOW2D_SAMPLE(textureName, samplerName, coord3)\n\t#define SAMPLE_TEXTURE2D_ARRAY_SHADOW(textureName, samplerName, coord3, index)              ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURE2D_ARRAY_SHADOW)\n\t#define SAMPLE_TEXTURECUBE_SHADOW(textureName, samplerName, coord4)                         SHADOWCUBE_SAMPLE(textureName, samplerName, coord4)\n\t#define SAMPLE_TEXTURECUBE_ARRAY_SHADOW(textureName, samplerName, coord4, index)            ERROR_ON_UNSUPPORTED_FUNCTION(SAMPLE_TEXTURECUBE_ARRAY_SHADOW)\n\n\n\t// Not supported. Can't define as error because shader library is calling these functions.\n\t#define LOAD_TEXTURE2D(textureName, unCoord2)                                               half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_LOD(textureName, unCoord2, lod)                                      half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_MSAA(textureName, unCoord2, sampleIndex)                             half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY(textureName, unCoord2, index)                                  half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_MSAA(textureName, unCoord2, index, sampleIndex)                half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE2D_ARRAY_LOD(textureName, unCoord2, index, lod)                         half4(0, 0, 0, 0)\n\t#define LOAD_TEXTURE3D(textureName, unCoord3)                                               ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D)\n\t#define LOAD_TEXTURE3D_LOD(textureName, unCoord3, lod)                                      ERROR_ON_UNSUPPORTED_FUNCTION(LOAD_TEXTURE3D_LOD)\n\n\t// Gather not supported. Fallback to regular texture sampling.\n\t#define GATHER_TEXTURE2D(textureName, samplerName, coord2)                  ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D)\n\t#define GATHER_TEXTURE2D_ARRAY(textureName, samplerName, coord2, index)     ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURE2D_ARRAY)\n\t#define GATHER_TEXTURECUBE(textureName, samplerName, coord3)                ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE)\n\t#define GATHER_TEXTURECUBE_ARRAY(textureName, samplerName, coord3, index)   ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_TEXTURECUBE_ARRAY)\n\t#define GATHER_RED_TEXTURE2D(textureName, samplerName, coord2)              ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_RED_TEXTURE2D)\n\t#define GATHER_GREEN_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_GREEN_TEXTURE2D)\n\t#define GATHER_BLUE_TEXTURE2D(textureName, samplerName, coord2)             ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_BLUE_TEXTURE2D)\n\t#define GATHER_ALPHA_TEXTURE2D(textureName, samplerName, coord2)            ERROR_ON_UNSUPPORTED_FUNCTION(GATHER_ALPHA_TEXTURE2D)\n\n#else\n#error unsupported shader api\n#endif\n\n\n\n\n// default flow control attributes\n#ifndef UNITY_BRANCH\n#   define UNITY_BRANCH\n#endif\n#ifndef UNITY_FLATTEN\n#   define UNITY_FLATTEN\n#endif\n#ifndef UNITY_UNROLL\n#   define UNITY_UNROLL\n#endif\n#ifndef UNITY_UNROLLX\n#   define UNITY_UNROLLX(_x)\n#endif\n#ifndef UNITY_LOOP\n#   define UNITY_LOOP\n#endif\n\n\n\n#define NEED_FACING 1\n\n         \n\n         // data across stages, stripped like the above.\n         struct VertexToPixel\n         {\n            UNITY_POSITION(pos);\n            float3 worldPos : TEXCOORD0;\n            float3 worldNormal : TEXCOORD1;\n            float4 worldTangent : TEXCOORD2;\n             float4 texcoord0 : TEXCOORD3;\n            // float4 texcoord1 : TEXCOORD4;\n            // float4 texcoord2 : TEXCOORD5;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // float4 texcoord3 : TEXCOORD6;\n            // #endif\n\n            // #if %SCREENPOSREQUIREKEY%\n            // float4 screenPos : TEXCOORD7;\n            // #endif\n\n            #ifdef EDITOR_VISUALIZATION\n              float2 vizUV : TEXCOORD8;\n              float4 lightCoord : TEXCOORD9;\n            #endif\n\n            \n            // #if %VERTEXCOLORREQUIREKEY%\n            // float4 vertexColor : COLOR;\n            // #endif\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // float4 extraV2F0 : TEXCOORD10;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // float4 extraV2F1 : TEXCOORD11;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // float4 extraV2F2 : TEXCOORD12;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // float4 extraV2F3 : TEXCOORD13;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // float4 extraV2F4 : TEXCOORD14;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // float4 extraV2F5 : TEXCOORD15;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // float4 extraV2F6 : TEXCOORD16;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // float4 extraV2F7 : TEXCOORD17;\n            // #endif\n\n\n            UNITY_VERTEX_INPUT_INSTANCE_ID\n            UNITY_VERTEX_OUTPUT_STEREO\n         };\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef UNITY_MATRIX_I_M\n\n               #define UNITY_MATRIX_I_M   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)UNITY_MATRIX_M, transpose(mul(UNITY_MATRIX_I_M, UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)UNITY_MATRIX_V, norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n            UNITY_SETUP_INSTANCE_ID(v);\n            VertexToPixel o;\n            UNITY_INITIALIZE_OUTPUT(VertexToPixel,o);\n            UNITY_TRANSFER_INSTANCE_ID(v,o);\n            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n\n            o.pos = UnityMetaVertexPosition(v.vertex, v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n            #ifdef EDITOR_VISUALIZATION\n               o.vizUV = 0;\n               o.lightCoord = 0;\n               if (unity_VisualizationMode == EDITORVIZ_TEXTURE)\n                  o.vizUV = UnityMetaVizUV(unity_EditorViz_UVIndex, v.texcoord0.xy, v.texcoord1.xy, v.texcoord2.xy, unity_EditorViz_Texture_ST);\n               else if (unity_VisualizationMode == EDITORVIZ_SHOWLIGHTMASK)\n               {\n                  o.vizUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n                  o.lightCoord = mul(unity_EditorViz_WorldToLight, mul(GetObjectToWorldMatrix(), float4(v.vertex.xyz, 1)));\n               }\n            #endif\n\n\n             o.texcoord0 = v.texcoord0;\n            // o.texcoord1 = v.texcoord1;\n            // o.texcoord2 = v.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // o.texcoord3 = v.texcoord3;\n            // #endif\n\n            // #if %VERTEXCOLORREQUIREKEY%\n            // o.vertexColor = v.vertexColor;\n            // #endif\n\n            // #if %SCREENPOSREQUIREKEY%\n            // o.screenPos = ComputeScreenPos(o.pos);\n            // #endif\n\n            o.worldPos = mul(GetObjectToWorldMatrix(), v.vertex).xyz;\n            o.worldNormal = UnityObjectToWorldNormal(v.normal);\n            o.worldTangent = float4(UnityObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n            return o;\n         }\n\n         \n\n         // fragment shader\n         fixed4 Frag (VertexToPixel IN\n         #if NEED_FACING\n            , bool facing : SV_IsFrontFace\n         #endif\n         ) : SV_Target\n         {\n            UNITY_SETUP_INSTANCE_ID(IN);\n\n            #ifdef FOG_COMBINED_WITH_TSPACE\n               UNITY_EXTRACT_FOG_FROM_TSPACE(IN);\n            #elif defined FOG_COMBINED_WITH_WORLD_POS\n               UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);\n            #else\n               UNITY_EXTRACT_FOG(IN);\n            #endif\n\n            ShaderData d = CreateShaderData(IN\n               #if NEED_FACING\n                 , facing\n              #endif\n            );\n\n            Surface l = (Surface)0;\n\n            l.Albedo = half3(0.5, 0.5, 0.5);\n            l.Normal = float3(0,0,1);\n            l.Occlusion = 1;\n            l.Alpha = 1;\n\n            \n            ChainSurfaceFunction(l, d);\n\n            UnityMetaInput metaIN;\n            UNITY_INITIALIZE_OUTPUT(UnityMetaInput, metaIN);\n            metaIN.Albedo = l.Albedo;\n            metaIN.Emission = l.Emission;\n          \n            #if _USESPECULAR\n               metaIN.SpecularColor = l.Specular;\n            #endif\n\n            #ifdef EDITOR_VISUALIZATION\n              metaIN.VizUV = IN.vizUV;\n              metaIN.LightCoord = IN.lightCoord;\n            #endif\n            return UnityMetaFragment(metaIN);\n         }\n         ENDCG\n\n      }\n\n      \n\n\n\n   }\n   \n   \n   \n}\n"},{"srpTarget":2,"UnityVersionMin":20212,"UnityVersionMax":20221,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2021.3.38f1\n//   Render Pipeline: HDRP2021\n//   Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader \"UMA/Diffuse_Normal_Metallic\"\n{\n   Properties\n   {\n      \n\n    [BetterHeader(Material Specific)]\n    _Color (\"Main Color\", Color) = (1, 1, 1, 1)\n\t_ColorModulation (\"Color Modulation\", Range(0,2)) = 1\n\t_MetallicModulation (\"Metallic Level\", Range(0,2)) = 1\n\t_SmoothnessModulation (\"Smoothness Level\", Range(0,2)) = 1\n\t[BetterHeader(Lighting Adjustment)]\n    [Toggle]_UseHalfLambert (\"Use Half Lambert\", Float) = 0\n    _HalfLambertStrength (\"Lambert(0), HalfLambert(1)\", Range(0,16)) = 1\n    _RimLightingModulation (\"Rim Lighting Level\", Float) = 0\n\t_RimLightColor(\"Rim Light Color\", Color) = (1,1,1,1)\n\t_RimLightPower(\"Rim Light Power\", Range(0.5, 12)) = 4\n\n    [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n    [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n    _BaseMap(\"BaseMap\", 2D) = \"white\" {}\n    _BumpMap(\"_BumpMap\", 2D) = \"bump\" {}\n    _NormalStrength (\"Normal Strength\", Range(0,2)) = 1\n    _MetallicGlossMap(\"_MetallicGlossMap\", 2D) = \"black\" {}\n    _UberTile(\"Uber Tile\", Range(0,16)) = 1\n\n\n\n\n      [HideInInspector]_RenderQueueType(\"Float\", Float) = 1\n      [HideInInspector][ToggleUI]_AddPrecomputedVelocity(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_DepthOffsetEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentWritingMotionVec(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaCutoffEnable(\"Boolean\", Float) = 0\n      [HideInInspector]_TransparentSortPriority(\"_TransparentSortPriority\", Float) = 0\n      [HideInInspector][ToggleUI]_UseShadowThreshold(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPrepassEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPostpassEnable(\"Boolean\", Float) = 0\n      [HideInInspector]_SurfaceType(\"Float\", Float) = 0\n      [HideInInspector]_BlendMode(\"Float\", Float) = 0\n      [HideInInspector]_SrcBlend(\"Float\", Float) = 1\n      [HideInInspector]_DstBlend(\"Float\", Float) = 0\n      [HideInInspector]_AlphaSrcBlend(\"Float\", Float) = 1\n      [HideInInspector]_AlphaDstBlend(\"Float\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMask(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMaskInspectorValue(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_ZWrite(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_TransparentZWrite(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_EnableFogOnTransparent(\"Boolean\", Float) = 1\n      [HideInInspector]_ZTestDepthEqualForOpaque(\"Float\", Int) = 4\n      [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)]_ZTestTransparent(\"Float\", Float) = 4\n      [HideInInspector][ToggleUI]_TransparentBackfaceEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_RequireSplitLighting(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_ReceivesSSR(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_ReceivesSSRTransparent(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_EnableBlendModePreserveSpecularLighting(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_SupportDecals(\"Boolean\", Float) = 1\n      [HideInInspector]_StencilRef(\"Float\", Int) = 0\n      [HideInInspector]_StencilWriteMask(\"Float\", Int) = 6\n      [HideInInspector]_StencilRefDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilWriteMaskDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilRefMV(\"Float\", Int) = 40\n      [HideInInspector]_StencilWriteMaskMV(\"Float\", Int) = 40\n      [HideInInspector]_StencilRefDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskGBuffer(\"Float\", Int) = 14\n      [HideInInspector]_StencilRefGBuffer(\"Float\", Int) = 10\n      [HideInInspector]_ZTestGBuffer(\"Float\", Int) = 4\n      [HideInInspector][ToggleUI]_RayTracing(\"Boolean\", Float) = 0\n      [HideInInspector][Enum(None, 0, Box, 1, Sphere, 2, Thin, 3)]_RefractionModel(\"Float\", Float) = 0\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\", 2DArray) = \"\" {}\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\" = \"HDRenderPipeline\" \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Geometry+225\" }\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n            \n            \n            Stencil\n            {\n               WriteMask [_StencilWriteMask]\n               Ref [_StencilRef]\n               CompFront Always\n               PassFront Replace\n               CompBack Always\n               PassBack Replace\n            }\n        \n            ColorMask [_ColorMaskTransparentVel] 1\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile_raytracing PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_raytracing _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT\n            #pragma multi_compile_fragment SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH SHADOW_VERY_HIGH\n            #pragma multi_compile_fragment SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON\n            #pragma multi_compile_fragment USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n                \n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_FORWARD\n            #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING\n            #define HAS_LIGHTLOOP\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define _PASSFORWARD 1\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n            #ifdef UNITY_VIRTUAL_TEXTURING\n            #define VT_BUFFER_TARGET SV_Target1\n            #define EXTRA_BUFFER_TARGET SV_Target2\n            #else\n            #define EXTRA_BUFFER_TARGET SV_Target1\n            #endif\n\n\n\n\n          void Frag(VertexToPixel v2p,\n              #ifdef OUTPUT_SPLIT_LIGHTING\n                  out float4 outColor : SV_Target0,  // outSpecularLighting\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                      out float4 outVTFeedback : VT_BUFFER_TARGET,\n                  #endif\n                  out float4 outDiffuseLighting : EXTRA_BUFFER_TARGET,\n                  OUTPUT_SSSBUFFER(outSSSBuffer)\n              #else\n                  out float4 outColor : SV_Target0\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                      ,out float4 outVTFeedback : VT_BUFFER_TARGET\n                  #endif\n                  #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                     , out float4 outMotionVec : EXTRA_BUFFER_TARGET\n                  #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n              #endif // OUTPUT_SPLIT_LIGHTING\n              #ifdef _DEPTHOFFSET_ON\n                  , out float outputDepth : SV_Depth\n              #endif\n              #if NEED_FACING\n                 , bool facing : SV_IsFrontFace\n              #endif\n          )\n          {\n              #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                 // Init outMotionVector here to solve compiler warning (potentially unitialized variable)\n                 // It is init to the value of forceNoMotion (with 2.0)\n                 outMotionVec = float4(2.0, 0.0, 0.0, 0.0);\n              #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n              FragInputs input = BuildFragInputs(v2p);\n\n              // We need to readapt the SS position as our screen space positions are for a low res buffer, but we try to access a full res buffer.\n              input.positionSS.xy = _OffScreenRendering > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;\n\n              uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();\n\n              // input.positionSS is SV_Position\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex);\n\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n            \n\n              BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n              PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n              outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip lighting when doing debug pass because the debug pass is done before lighting so some buffers may not be properly initialized potentially causing crashes on PS4.\n\n             #ifdef DEBUG_DISPLAY\n                 // Init in debug display mode to quiet warning\n                #ifdef OUTPUT_SPLIT_LIGHTING\n                    outDiffuseLighting = 0;\n                    ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n                #endif\n\n              \n\n              // Same code in ShaderPassForwardUnlit.shader\n              // Reminder: _DebugViewMaterialArray[i]\n              //   i==0 -> the size used in the buffer\n              //   i>0  -> the index used (0 value means nothing)\n              // The index stored in this buffer could either be\n              //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only one supported)\n              //   - a property index which is different for each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n              bool viewMaterial = false;\n              int bufferSize = _DebugViewMaterialArray[0].x;\n              if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                  // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug will do nothing if the index is not a known one\n                  for (int index = 1; index <= bufferSize; index++)\n                  {\n                      int indexMaterialProperty = _DebugViewMaterialArray[index].x;\n\n                      // skip if not really in use\n                      if (indexMaterialProperty != 0)\n                      {\n                          viewMaterial = true;\n\n                          GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                          GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                          GetBuiltinDataDebug(indexMaterialProperty, builtinData, posInput, result, needLinearToSRGB);\n                          GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                          GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                      }\n                  }\n\n                  // TEMP!\n                  // For now, the final blit in the backbuffer performs an sRGB write\n                  // So in the meantime we apply the inverse transform to linear data to compensate.\n                  if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0, result));\n\n                  outColor = float4(result, 1.0);\n              }\n\n              if (!viewMaterial)\n              {\n                  if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData, result);\n\n                      outColor = float4(result, 1.0f);\n                  }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                  {\n                      float4 result = _DebugTransparencyOverdrawWeight * float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                  }\n                  else\n          #endif\n                  {\n          #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                      LightLoopOutput lightLoopOutput;\n                      LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                      float3 diffuseLighting = lightLoopOutput.diffuseLighting;\n                      float3 specularLighting = lightLoopOutput.specularLighting;\n\n                      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                      {\n                          outColor = float4(specularLighting, 1.0);\n                          outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                      }\n                      else\n                      {\n                          outColor = float4(diffuseLighting + specularLighting, 1.0);\n                          outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n          #else\n                      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n          #endif\n\n          ChainFinalColorForward(l, d, outColor);\n\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                      bool forceNoMotion = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec is already initialize at the value of forceNoMotion (see above)\n                      if (!forceNoMotion)\n                      {\n                          float2 motionVec = CalculateMotionVector(v2p.motionVectorCS, v2p.previousPositionCS);\n                          EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                          outMotionVec.zw = 1.0;\n                      }\n          #endif\n                  }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n          #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n          #endif\n\n          #ifdef UNITY_VIRTUAL_TEXTURING\n             outVTFeedback = builtinData.vtPackedFeedback;\n          #endif\n          }\n\n            ENDHLSL\n        }\n               Pass\n        {\n            // based on HDLitPass.template\n            Name \"GBuffer\"\n            Tags { \"LightMode\" = \"GBuffer\" }\n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n            ZTest [_ZTestGBuffer]\n            Stencil\n               {\n                  WriteMask [_StencilWriteMaskGBuffer]\n                  Ref [_StencilRefGBuffer]\n                  CompFront Always\n                  PassFront Replace\n                  CompBack Always\n                  PassBack Replace\n               }\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n        \n\n            #pragma multi_compile _ LIGHT_LAYERS\n            #pragma multi_compile_raytracing _ LIGHT_LAYERS\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile_raytracing PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_raytracing _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT\n                \n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n\n\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_GBUFFER\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define _PASSGBUFFER 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n           \n            //-------------------------------------------------------------------------------------\n            // Defines\n            //-------------------------------------------------------------------------------------\n\n\n            \n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n            void Frag(  VertexToPixel v2f,\n                        OUTPUT_GBUFFER(outGBuffer)\n                        #ifdef _DEPTHOFFSET_ON\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                        )\n            {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n                    #if NEED_FACING\n                      , facing\n                    #endif\n                  );\n\n         \n                  ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);\n\n                  #ifdef _DEPTHOFFSET_ON\n                        outputDepth = l.outputDepth;\n                  #endif\n            }\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"ShadowCaster\"\n            Tags { \"LightMode\" = \"ShadowCaster\" }\n\n            \n\n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n            ZWrite On\n            ColorMask 0\n            ZClip [_ZClip]\n    \n\n               Cull [_CullMode]\n\n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n\n            //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_SHADOWS\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define _PASSSHADOW 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            //-------------------------------------------------------------------------------------\n            // Defines\n            //-------------------------------------------------------------------------------------\n            \n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n        \n\n            #if defined(WRITE_NORMAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n               #define SV_TARGET_DECAL SV_Target2\n            #elif defined(WRITE_NORMAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n               #define SV_TARGET_DECAL SV_Target1\n            #else\n               #define SV_TARGET_DECAL SV_Target0\n            #endif\n\n\n              void Frag(  VertexToPixel v2f\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                          , out float4 outColor : SV_Target0\n                          #else\n                          #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color as SV_Target0 for alpha to coverage\n                            , out float4 depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target1\n                                #endif\n                            #else\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target0\n                                #endif\n                            #endif\n\n                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                            , out float4 outDecalBuffer : SV_TARGET_DECAL\n                            #endif\n                        #endif\n\n                        #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n         \n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n                  #ifdef _DEPTHOFFSET_ON\n                     outputDepth = l.outputDepth;\n                  #endif\n\n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2f.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  #endif\n\n                   #if defined(WRITE_NORMAL_BUFFER)\n                      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                   #endif\n\n                   #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                      DecalPrepassData decalPrepassData;\n                      // We don't have the right to access SurfaceData in a shaderpass.\n                      // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                      // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                      decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                      decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                      EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                   #endif\n\n\n              }\n\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"DepthOnly\"\n            Tags { \"LightMode\" = \"DepthOnly\" }\n            \n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n        \n            \n            ZWrite On\n        \n            \n            // Stencil setup\n        Stencil\n        {\n           WriteMask [_StencilWriteMaskDepth]\n           Ref [_StencilRefDepth]\n           Comp Always\n           Pass Replace\n        }\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n        \n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n            #pragma multi_compile _ WRITE_MSAA_DEPTH\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define _PASSDEPTH 1\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n              #if defined(WRITE_NORMAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n              #define SV_TARGET_DECAL SV_Target2\n              #elif defined(WRITE_NORMAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n              #define SV_TARGET_DECAL SV_Target1\n              #else\n              #define SV_TARGET_DECAL SV_Target0\n              #endif\n\n\n              void Frag(  VertexToPixel v2p\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                          , out float4 outColor : SV_Target0\n                          #else\n                          #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color as SV_Target0 for alpha to coverage\n                            , out float4 depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target1\n                                #endif\n                            #else\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target0\n                                #endif\n                            #endif\n\n                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                            , out float4 outDecalBuffer : SV_TARGET_DECAL\n                            #endif\n                        #endif\n\n                        #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n                  FragInputs input = BuildFragInputs(v2p);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n    \n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n                  // to prevent stripping\n                  surfaceData.normalWS *= saturate(l.Albedo.r + 9999);\n\n                  #ifdef _DEPTHOFFSET_ON\n                     outputDepth = l.outputDepth;\n                  #endif\n\n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                     #endif\n\n                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                        DecalPrepassData decalPrepassData;\n                        // We don't have the right to access SurfaceData in a shaderpass.\n                        // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                        // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                        decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                     #endif\n                  #endif\n\n              }\n\n\n\n         ENDHLSL\n    }\n\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"META\"\n            Tags { \"LightMode\" = \"META\" }\n            \n            Cull Off\n        \n               Cull [_CullMode]\n\n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n\n        \n            #pragma multi_compile_instancing\n\n            //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define REQUIRE_DEPTH_TEXTURE\n            #define _PASSMETA 1\n\n        \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n\n            \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n            float4 Frag(VertexToPixel v2f\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n            {\n                FragInputs input = BuildFragInputs(v2f);\n\n                // input.positionSS is SV_Position\n                PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n                SurfaceData surfaceData;\n                BuiltinData builtinData;\n                Surface l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n                // no debug apply during light transport pass\n\n                BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n                LightTransportData lightTransportData = GetLightTransportData(surfaceData, builtinData, bsdfData);\n\n                // This shader is call two times. Once for getting emissiveColor, the other time to get diffuseColor\n                // We use unity_MetaFragmentControl to make the distinction.\n                float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n                {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                    // put abs here to silent a warning, no cost, no impact as color is assume to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor), saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n                }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                    // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n                }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\" }\n        \n            Cull Off\n            ColorMask 0\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n            #pragma instancing_options renderinglayer\n        \n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define SCENESELECTIONPASS\n            #define _PASSSCENESELECT 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            \n\n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n        \n\n            \n            void Frag(  VertexToPixel IN\n            #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_Target0\n                #ifdef WRITE_MSAA_DEPTH\n                , out float1 depthColor : SV_Target1\n                #endif\n            #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth, but we still have normal buffer binded\n            , out float4 outNormalBuffer : SV_Target0\n            , out float1 depthColor : SV_Target1\n            #elif defined(SCENESELECTIONPASS)\n            , out float4 outColor : SV_Target0\n            #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n        )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n             FragInputs input = BuildFragInputs(IN);\n\n             // input.positionSS is SV_Position\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n\n             float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n            SurfaceData surfaceData;\n            BuiltinData builtinData;\n            Surface l;\n            ShaderData d;\n            GetSurfaceAndBuiltinData(IN, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = l.outputDepth;\n         #endif\n\n         #ifdef WRITE_NORMAL_BUFFER\n             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS, outNormalBuffer);\n             #ifdef WRITE_MSAA_DEPTH\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n             #endif\n         #elif defined(WRITE_MSAA_DEPTH) // When we are MSAA depth only without normal buffer\n             // Due to the binding order of these two render targets, we need to have them both declared\n             outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n         #elif defined(SCENESELECTIONPASS)\n             // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n             outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n         #endif\n         }\n\n         ENDHLSL\n     }\n\n        \n              Pass\n        {\n            Name \"ScenePickingPass\"\n            Tags\n            {\n               \"LightMode\" = \"Picking\"\n            }\n            \n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n            #pragma instancing_options renderinglayer\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n        \n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENEPICKINGPASS\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n            void Frag( VertexToPixel v2f\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                          , out float4 outColor : SV_Target0\n                          #else\n                          #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color as SV_Target0 for alpha to coverage\n                            , out float4 depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target1\n                                #endif\n                            #else\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target0\n                                #endif\n                            #endif\n\n                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                            , out float4 outDecalBuffer : SV_TARGET_DECAL\n                            #endif\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n                  \n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                     #endif\n\n                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                        DecalPrepassData decalPrepassData;\n                        // We don't have the right to access SurfaceData in a shaderpass.\n                        // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                        // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                        decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                     #endif\n                  #endif\n\n\n              }\n\n         ENDHLSL\n        }\n\n              Pass\n        {\n            Name \"MotionVectors\"\n            Tags\n            {\n               \"LightMode\" = \"MotionVectors\"\n            }\n    \n            // Render State\n            Cull Back\n            ZWrite On\n            Stencil\n               {\n                  WriteMask [_StencilWriteMaskMV]\n                  Ref [_StencilRefMV]\n                  CompFront Always\n                  PassFront Replace\n                  CompBack Always\n                  PassBack Replace\n               }\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n\n\n            #pragma multi_compile _ WRITE_MSAA_DEPTH\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n\n            #define SHADERPASS SHADERPASS_MOTION_VECTORS\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define VARYINGS_NEED_PASS\n            #define _PASSMOTIONVECTOR 1\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n#if defined(WRITE_DECAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n#define SV_TARGET_NORMAL SV_Target3\n#elif defined(WRITE_DECAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n#define SV_TARGET_NORMAL SV_Target2\n#else\n#define SV_TARGET_NORMAL SV_Target1\n#endif\n\n// Caution: Motion vector pass is different from Depth prepass, it render normal buffer last instead of decal buffer last\n// and thus, we force a write of 0 if _DISABLE_DECALS so we always write in the decal buffer.\n// This is required as we can't make distinction  between deferred (write normal buffer) and forward (write normal buffer)\n// in the context of the motion vector pass. The cost is acceptable as it is only do object with motion vector (usualy skin object)\n// that most of the time use Forward Material (so are already writing motion vector data).\n// So note that here unlike for depth prepass we don't check && !defined(_DISABLE_DECALS)\nvoid Frag(  VertexToPixel v2f\n            #ifdef WRITE_MSAA_DEPTH\n            // We need the depth color as SV_Target0 for alpha to coverage\n            , out float4 depthColor : SV_Target0\n            , out float4 outMotionVector : SV_Target1\n                #ifdef WRITE_DECAL_BUFFER\n                , out float4 outDecalBuffer : SV_Target2\n                #endif\n            #else\n            // When no MSAA, the motion vector is always the first buffer\n            , out float4 outMotionVector : SV_Target0\n                #ifdef WRITE_DECAL_BUFFER\n                , out float4 outDecalBuffer : SV_Target1\n                #endif\n            #endif\n\n            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n            #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_TARGET_NORMAL\n            #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n        )\n          {\n\n              FragInputs input = BuildFragInputs(v2f);\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n            #ifdef _DEPTHOFFSET_ON\n                v2f.motionVectorCS.w += builtinData.depthOffset;\n                v2f.previousPositionCS.w += builtinData.depthOffset;\n            #endif\n\n             // TODO: How to allow overriden motion vector from GetSurfaceAndBuiltinData ?\n             float2 motionVector = CalculateMotionVector(v2f.motionVectorCS, v2f.previousPositionCS);\n\n             // Convert from Clip space (-1..1) to NDC 0..1 space.\n             // Note it doesn't mean we don't have negative value, we store negative or positive offset in NDC space.\n             // Note: ((positionCS * 0.5 + 0.5) - (v2f.previousPositionCS * 0.5 + 0.5)) = (motionVector * 0.5)\n             EncodeMotionVector(motionVector * 0.5, outMotionVector);\n\n             // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n             bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n             // Setting the motionVector to a value more than 2 set as a flag for \"force no motion\". This is valid because, given that the velocities are in NDC,\n             // a value of >1 can never happen naturally, unless explicitely set. \n             if (forceNoMotion)\n                 outMotionVector = float4(2.0, 0.0, 0.0, 0.0);\n\n         // Depth and Alpha to coverage\n         #ifdef WRITE_MSAA_DEPTH\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n\n             #ifdef _ALPHATOMASK_ON\n             // Alpha channel is used for alpha to coverage\n             depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n             #endif\n         #endif\n\n         // Normal Buffer Processing\n         #ifdef WRITE_NORMAL_BUFFER\n             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n         #endif\n\n         #if defined(WRITE_DECAL_BUFFER)\n             DecalPrepassData decalPrepassData;\n             // Force a write in decal buffer even if decal is disab. This is a neutral value which have no impact for later pass\n             #ifdef _DISABLE_DECALS\n             ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);\n             #else\n             // We don't have the right to access SurfaceData in a shaderpass.\n             // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n             // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n             decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n             decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n             #endif\n             EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n             outDecalBuffer.w = (GetMeshRenderingLightLayer() & 0x000000FF) / 255.0;\n         #endif\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = posInput.deviceDepth;\n         #endif\n          }\n\n            ENDHLSL\n        }\n\n      \n              Pass\n        {\n            Name \"FullScreenDebug\"\n            Tags\n            {\n               \"LightMode\" = \"FullScreenDebug\"\n            }\n    \n            // Render State\n            Cull Back\n            ZTest LEqual\n            ZWrite Off\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n\n            #define SHADERPASS SHADERPASS_FULL_SCREEN_DEBUG\n            #define _PASSFULLSCREENDEBUG 1\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n\n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n#if UNITY_VERSION >= UNITY_2021_3_31\n       #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif    \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n            \n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n                \n\n\n                   // compute world space normal\n                   #if !_WORLDSPACENORMAL\n                      surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                   #else\n                      surfaceData.normalWS = surfaceDescription.Normal;\n                   #endif\n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n         \n                    #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                \n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs.tangentToWorld[2], alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                    #endif\n                \n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    //posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, fragInputs.texCoord1, fragInputs.texCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                 #if defined(UNITY_VIRTUAL_TEXTURING)\n                    builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                 #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n#define DEBUG_DISPLAY\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl\"\n\n         #if !defined(_DEPTHOFFSET_ON)\n         [earlydepthstencil] // quad overshading debug mode writes to UAV\n         #endif\n         void Frag(VertexToPixel v2f\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n             FragInputs input = BuildFragInputs(v2f);\n\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz);\n\n         #ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER\n             if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)\n             {\n                 IncrementQuadOverdrawCounter(posInput.positionSS.xy, input.primitiveID);\n             }\n         #endif\n         }\n\n            ENDHLSL\n        }\n\n      \n\n\n      \n   }\n\n   \n   \n   \n}\n"},{"srpTarget":1,"UnityVersionMin":20212,"UnityVersionMax":20221,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2021.3.38f1\n//   Render Pipeline: URP2021\n//   Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader \"UMA/Diffuse_Normal_Metallic\"\n{\n   Properties\n   {\n      [HideInInspector]_QueueOffset(\"_QueueOffset\", Float) = 0\n      [HideInInspector]_QueueControl(\"_QueueControl\", Float) = -1\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\", 2DArray) = \"\" {}\n      \n\n    [BetterHeader(Material Specific)]\n    _Color (\"Main Color\", Color) = (1, 1, 1, 1)\n\t_ColorModulation (\"Color Modulation\", Range(0,2)) = 1\n\t_MetallicModulation (\"Metallic Level\", Range(0,2)) = 1\n\t_SmoothnessModulation (\"Smoothness Level\", Range(0,2)) = 1\n\t[BetterHeader(Lighting Adjustment)]\n    [Toggle]_UseHalfLambert (\"Use Half Lambert\", Float) = 0\n    _HalfLambertStrength (\"Lambert(0), HalfLambert(1)\", Range(0,16)) = 1\n    _RimLightingModulation (\"Rim Lighting Level\", Float) = 0\n\t_RimLightColor(\"Rim Light Color\", Color) = (1,1,1,1)\n\t_RimLightPower(\"Rim Light Power\", Range(0.5, 12)) = 4\n\n    [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n    [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n    _BaseMap(\"BaseMap\", 2D) = \"white\" {}\n    _BumpMap(\"_BumpMap\", 2D) = \"bump\" {}\n    _NormalStrength (\"Normal Strength\", Range(0,2)) = 1\n    _MetallicGlossMap(\"_MetallicGlossMap\", 2D) = \"black\" {}\n    _UberTile(\"Uber Tile\", Range(0,16)) = 1\n\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\" \"RenderType\" = \"Opaque\" \"UniversalMaterialType\" = \"Lit\" \"Queue\" = \"Geometry\" }\n\n      \n\n      \n        Pass\n        {\n            Name \"Universal Forward\"\n            Tags \n            { \n                \"LightMode\" = \"UniversalForward\"\n            }\n            Cull Back\n            Blend One Zero\n            ZTest LEqual\n            ZWrite On\n\n            Blend One Zero, One Zero\nCull Back\nZTest LEqual\nZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n    \n            // Keywords\n            #pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\n            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS\n            #pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT\n            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3\n            #pragma multi_compile_fragment _ _LIGHT_LAYERS\n            #pragma multi_compile_fragment _ DEBUG_DISPLAY\n            #pragma multi_compile_fragment _ _LIGHT_COOKIES\n            #pragma multi_compile _ _CLUSTERED_RENDERING\n            // GraphKeywords: <None>\n\n            #define SHADER_PASS SHADERPASS_FORWARD\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define _PASSFORWARD 1\n            #define _FOG_FRAGMENT 1\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DBuffer.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            \n\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n         \n\n#if _UNLIT\n   #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Unlit.hlsl\"  \n#endif\n\n         // fragment shader\n         half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n           #if _USESPECULAR || _SIMPLELIT\n              float3 specular = l.Specular;\n              float metallic = 1;\n           #else   \n              float3 specular = 0;\n              float metallic = l.Metallic;\n           #endif\n\n\n            \n           \n            InputData inputData = (InputData)0;\n\n            inputData.positionWS = IN.worldPos;\n            #if _WORLDSPACENORMAL\n              inputData.normalWS = l.Normal;\n            #else\n              inputData.normalWS = normalize(TangentToWorldSpace(d, l.Normal));\n            #endif\n\n            inputData.viewDirectionWS = SafeNormalize(d.worldSpaceViewDir);\n\n\n            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n                  inputData.shadowCoord = IN.shadowCoord;\n            #elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                  inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n            #else\n                  inputData.shadowCoord = float4(0, 0, 0, 0);\n            #endif\n            \n#if _BAKEDLIT\n            inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n            inputData.vertexLighting = 0;\n#else\n            inputData.fogCoord = InitializeInputDataFog(float4(IN.worldPos, 1.0), IN.fogFactorAndVertexLight.x);\n            inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n#endif    \n\n\n\n            #if defined(_OVERRIDE_BAKEDGI)\n               inputData.bakedGI = l.DiffuseGI;\n               l.Emission += l.SpecularGI;\n            #elif _BAKEDLIT\n               inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n            #else\n               #if defined(DYNAMICLIGHTMAP_ON)\n                  inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.dynamicLightmapUV.xy, IN.sh, inputData.normalWS);\n               #else\n                  inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n               #endif\n            #endif\n            inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n            #if !_BAKEDLIT\n               inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n           \n               #if defined(_OVERRIDE_SHADOWMASK)\n                  float4 mulColor = saturate(dot(l.ShadowMask, _MainLightOcclusionProbes)); //unity_OcclusionMaskSelector));\n                  inputData.shadowMask = mulColor;\n               #endif\n            #else\n               inputData.shadowMask = float4(1,1,1,1);\n            #endif\n\n            #if defined(DEBUG_DISPLAY)\n                #if defined(DYNAMICLIGHTMAP_ON)\n                  inputData.dynamicLightmapUV = IN.dynamicLightmapUV.xy;\n                #endif\n                #if defined(LIGHTMAP_ON)\n                  inputData.staticLightmapUV = IN.lightmapUV;\n                #else\n                  inputData.vertexSH = IN.sh;\n                #endif\n            #endif\n\n            #if _WORLDSPACENORMAL\n              float3 normalTS = WorldToTangentSpace(d, l.Normal);\n            #else\n              float3 normalTS = l.Normal;\n            #endif\n\n            SurfaceData surface         = (SurfaceData)0;\n            surface.albedo              = l.Albedo;\n            surface.metallic            = saturate(metallic);\n            surface.specular            = specular;\n            surface.smoothness          = saturate(l.Smoothness),\n            surface.occlusion           = l.Occlusion,\n            surface.emission            = l.Emission,\n            surface.alpha               = saturate(l.Alpha);\n            surface.clearCoatMask       = 0;\n            surface.clearCoatSmoothness = 1;\n\n            #ifdef _CLEARCOAT\n                  surface.clearCoatMask       = saturate(l.CoatMask);\n                  surface.clearCoatSmoothness = saturate(l.CoatSmoothness);\n            #endif\n\n            #if !_UNLIT\n               half4 color = half4(l.Albedo, l.Alpha);\n               #ifdef _DBUFFER\n                  #if _BAKEDLIT\n                     half3 bakeColor = color.rgb;\n                     float3 bakeNormal = inputData.normalWS.xyz;\n                     ApplyDecalToBaseColorAndNormal(IN.pos, bakeColor, bakeNormal);\n                     color.rgb = bakeColor;\n                     inputData.normalWS.xyz = bakeNormal;\n                  #else\n                     ApplyDecalToSurfaceData(IN.pos, surface, inputData);\n                  #endif\n               #endif\n               #if _SIMPLELIT\n                  color = UniversalFragmentBlinnPhong(\n                     inputData,\n                     surface);\n               #elif _BAKEDLIT\n                  color = UniversalFragmentBakedLit(inputData, color.rgb, color.a, normalTS);\n               #else\n                  color = UniversalFragmentPBR(inputData, surface);\n               #endif\n\n               #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n               #endif\n\n            #else // unlit\n               #ifdef _DBUFFER\n                  ApplyDecalToSurfaceData(IN.pos, surface, inputData);\n               #endif\n               half4 color = UniversalFragmentUnlit(inputData, l.Albedo, l.Alpha);\n               #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n               #endif\n            #endif\n            ChainFinalColorForward(l, d, color);\n\n            return color;\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"GBuffer\"\n            Tags\n            {\n               \"LightMode\" = \"UniversalGBuffer\"\n            }\n           \n             Blend One Zero\n             ZTest LEqual\n             ZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n            #pragma multi_compile_fog\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            \n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT\n            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE\n            #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3\n            #pragma multi_compile_fragment _ _GBUFFER_NORMALS_OCT\n            #pragma multi_compile_fragment _ _LIGHT_LAYERS\n            #pragma multi_compile_fragment _ _RENDER_PASS_ENABLED\n            #pragma multi_compile_fragment _ DEBUG_DISPLAY\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            \n            #define _FOG_FRAGMENT 1\n\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define SHADERPASS SHADERPASS_GBUFFER\n            #define _PASSGBUFFER 1\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            \n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DBuffer.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            \n\n            \n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityGBuffer.hlsl\"\n\n            // fragment shader\n            FragmentOutput Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) \n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n               #if _USESPECULAR || _SIMPLELIT\n                  float3 specular = l.Specular;\n                  float metallic = 0;\n               #else   \n                  float3 specular = 0;\n                  float metallic = l.Metallic;\n               #endif\n\n               InputData inputData = (InputData)0;\n\n               inputData.positionWS = IN.worldPos;\n               #if _WORLDSPACENORMAL\n                  inputData.normalWS = l.Normal;\n               #else\n                  inputData.normalWS = normalize(TangentToWorldSpace(d, l.Normal));\n               #endif\n\n               inputData.viewDirectionWS = SafeNormalize(d.worldSpaceViewDir);\n\n\n               #if defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                   inputData.shadowCoord = TransformWorldToShadowCoord(inputData.positionWS);\n               #else\n                   inputData.shadowCoord = float4(0, 0, 0, 0);\n               #endif\n\n               //inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n               InitializeInputDataFog(float4(IN.worldPos, 1.0), IN.fogFactorAndVertexLight.x);\n               inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n\n\n               #if defined(_OVERRIDE_BAKEDGI)\n                  inputData.bakedGI = l.DiffuseGI;\n                  l.Emission += l.SpecularGI;\n               #else\n                  #if defined(DYNAMICLIGHTMAP_ON)\n                   inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.dynamicLightmapUV.xy, IN.sh, inputData.normalWS);\n                  #else\n                      inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n                  #endif\n               #endif\n\n               inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n               inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n\n               #if defined(DEBUG_DISPLAY)\n                   #if defined(DYNAMICLIGHTMAP_ON)\n                     inputData.dynamicLightmapUV = IN.dynamicLightmapUV.xy;\n                   #endif\n                   #if defined(LIGHTMAP_ON)\n                     inputData.staticLightmapUV = IN.lightmapUV;\n                   #else\n                     inputData.vertexSH = IN.sh;\n                   #endif\n               #endif\n\n               #ifdef _DBUFFER\n                   ApplyDecal(IN.pos,\n                       l.Albedo,\n                       specular,\n                       inputData.normalWS,\n                       metallic,\n                       l.Occlusion,\n                       l.Smoothness);\n               #endif\n\n               BRDFData brdfData;\n               InitializeBRDFData(l.Albedo, metallic, specular, l.Smoothness, l.Alpha, brdfData);\n               Light mainLight = GetMainLight(inputData.shadowCoord, inputData.positionWS, inputData.shadowMask);\n               MixRealtimeAndBakedGI(mainLight, inputData.normalWS, inputData.bakedGI, inputData.shadowMask);\n               half3 color = GlobalIllumination(brdfData, inputData.bakedGI, l.Occlusion, inputData.positionWS, inputData.normalWS, inputData.viewDirectionWS);\n\n               return BRDFDataToGbuffer(brdfData, inputData, l.Smoothness, l.Emission + color, l.Occlusion);\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"ShadowCaster\"\n            Tags \n            { \n                \"LightMode\" = \"ShadowCaster\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n  \n            #pragma multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW\n\n\n            #define _NORMAL_DROPOFF_TS 1\n            #define ATTRIBUTES_NEED_NORMAL\n            #define ATTRIBUTES_NEED_TANGENT\n            #define _PASSSHADOW 1\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n                 \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n   \n            \n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n         \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n             return 0;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"DepthOnly\"\n            Tags \n            { \n                \"LightMode\" = \"DepthOnly\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            ColorMask 0\n            \n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n\n            #define _PASSDEPTH 1\n\n            #pragma target 3.0\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n         \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n               return 0;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"Meta\"\n            Tags \n            { \n                \"LightMode\" = \"Meta\"\n            }\n\n            Cull Off\n            \n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n        \n            #define SHADERPASS SHADERPASS_META\n            #define _PASSMETA 1\n\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n\n               Surface l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n               metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"DepthNormals\"\n            Tags\n            {\n               \"LightMode\" = \"DepthNormals\"\n            }\n    \n            // Render State\n             Cull Back\n                ZTest LEqual\n                ZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n\n\n            #define SHADERPASS SHADERPASS_DEPTHNORMALSONLY\n            #define _PASSDEPTH 1\n            #define _PASSDEPTHNORMALS 1\n\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n\n            \n\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n         \n\n         // fragment shader\n         half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         ) : SV_Target\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n          #if defined(_GBUFFER_NORMALS_OCT)\n              float3 normalWS = d.worldSpaceNormal;\n              float2 octNormalWS = PackNormalOctQuadEncode(normalWS);           // values between [-1, +1], must use fp32 on some platforms\n              float2 remappedOctNormalWS = saturate(octNormalWS * 0.5 + 0.5);   // values between [ 0,  1]\n              half3 packedNormalWS = PackFloat2To888(remappedOctNormalWS);      // values between [ 0,  1]\n              return half4(packedNormalWS, 0.0);\n          #else\n              float3 wsn = l.Normal;\n              #if !_WORLDSPACENORMAL\n                wsn = TangentToWorldSpace(d, l.Normal);\n              #endif\n              return half4(NormalizeNormalPerPixel(wsn), 0.0);\n          #endif\n\n         \n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n\n\n      \n\n   }\n   \n   \n   \n}\n"},{"srpTarget":2,"UnityVersionMin":20222,"UnityVersionMax":20233,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2021.3.38f1\n//   Render Pipeline: HDRP2022\n//   Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader \"UMA/Diffuse_Normal_Metallic\"\n{\n   Properties\n   {\n      \n\n    [BetterHeader(Material Specific)]\n    _Color (\"Main Color\", Color) = (1, 1, 1, 1)\n\t_ColorModulation (\"Color Modulation\", Range(0,2)) = 1\n\t_MetallicModulation (\"Metallic Level\", Range(0,2)) = 1\n\t_SmoothnessModulation (\"Smoothness Level\", Range(0,2)) = 1\n\t[BetterHeader(Lighting Adjustment)]\n    [Toggle]_UseHalfLambert (\"Use Half Lambert\", Float) = 0\n    _HalfLambertStrength (\"Lambert(0), HalfLambert(1)\", Range(0,16)) = 1\n    _RimLightingModulation (\"Rim Lighting Level\", Float) = 0\n\t_RimLightColor(\"Rim Light Color\", Color) = (1,1,1,1)\n\t_RimLightPower(\"Rim Light Power\", Range(0.5, 12)) = 4\n\n    [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n    [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n    _BaseMap(\"BaseMap\", 2D) = \"white\" {}\n    _BumpMap(\"_BumpMap\", 2D) = \"bump\" {}\n    _NormalStrength (\"Normal Strength\", Range(0,2)) = 1\n    _MetallicGlossMap(\"_MetallicGlossMap\", 2D) = \"black\" {}\n    _UberTile(\"Uber Tile\", Range(0,16)) = 1\n\n\n\n\n      [HideInInspector]_RenderQueueType(\"Float\", Float) = 1\n      [HideInInspector][ToggleUI]_AddPrecomputedVelocity(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_DepthOffsetEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentWritingMotionVec(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaCutoffEnable(\"Boolean\", Float) = 0\n      [HideInInspector]_TransparentSortPriority(\"_TransparentSortPriority\", Float) = 0\n      [HideInInspector][ToggleUI]_UseShadowThreshold(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPrepassEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPostpassEnable(\"Boolean\", Float) = 0\n      [HideInInspector]_SurfaceType(\"Float\", Float) = 0\n      [HideInInspector]_BlendMode(\"Float\", Float) = 0\n      [HideInInspector]_SrcBlend(\"Float\", Float) = 1\n      [HideInInspector]_DstBlend(\"Float\", Float) = 0\n      [HideInInspector]_AlphaSrcBlend(\"Float\", Float) = 1\n      [HideInInspector]_AlphaDstBlend(\"Float\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMask(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMaskInspectorValue(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_ZWrite(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_TransparentZWrite(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_EnableFogOnTransparent(\"Boolean\", Float) = 1\n      [HideInInspector]_ZTestDepthEqualForOpaque(\"Float\", Int) = 4\n      [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)]_ZTestTransparent(\"Float\", Float) = 4\n      [HideInInspector][ToggleUI]_TransparentBackfaceEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_RequireSplitLighting(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_ReceivesSSR(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_ReceivesSSRTransparent(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_EnableBlendModePreserveSpecularLighting(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_SupportDecals(\"Boolean\", Float) = 1\n      [HideInInspector]_StencilRef(\"Float\", Int) = 0\n      [HideInInspector]_StencilWriteMask(\"Float\", Int) = 6\n      [HideInInspector]_StencilRefDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilWriteMaskDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilRefMV(\"Float\", Int) = 40\n      [HideInInspector]_StencilWriteMaskMV(\"Float\", Int) = 40\n      [HideInInspector]_StencilRefDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskGBuffer(\"Float\", Int) = 14\n      [HideInInspector]_StencilRefGBuffer(\"Float\", Int) = 10\n      [HideInInspector]_ZTestGBuffer(\"Float\", Int) = 4\n      [HideInInspector][ToggleUI]_RayTracing(\"Boolean\", Float) = 0\n      [HideInInspector][Enum(None, 0, Box, 1, Sphere, 2, Thin, 3)]_RefractionModel(\"Float\", Float) = 0\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\", 2DArray) = \"\" {}\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\" = \"HDRenderPipeline\" \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Geometry+225\" }\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n            \n            \n            Stencil\n            {\n               WriteMask [_StencilWriteMask]\n               Ref [_StencilRef]\n               CompFront Always\n               PassFront Replace\n               CompBack Always\n               PassBack Replace\n            }\n        \n            ColorMask [_ColorMaskTransparentVel] 1\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n\n            #pragma target 4.5\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n            \n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile_raytracing PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_raytracing _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT\n            #pragma multi_compile_fragment SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n            #pragma multi_compile_fragment SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON\n            #pragma multi_compile_fragment USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n            #pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n            \n                 \n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_FORWARD\n            #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING\n            #define HAS_LIGHTLOOP\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define _PASSFORWARD 1\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n            #ifdef UNITY_VIRTUAL_TEXTURING\n            #define VT_BUFFER_TARGET SV_Target1\n            #define EXTRA_BUFFER_TARGET SV_Target2\n            #else\n            #define EXTRA_BUFFER_TARGET SV_Target1\n            #endif\n\n\n\n\n          void Frag(VertexToPixel v2p,\n              #ifdef OUTPUT_SPLIT_LIGHTING\n                  out float4 outColor : SV_Target0,  // outSpecularLighting\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                      out float4 outVTFeedback : VT_BUFFER_TARGET,\n                  #endif\n                  out float4 outDiffuseLighting : EXTRA_BUFFER_TARGET,\n                  OUTPUT_SSSBUFFER(outSSSBuffer)\n              #else\n                  out float4 outColor : SV_Target0\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                      ,out float4 outVTFeedback : VT_BUFFER_TARGET\n                  #endif\n                  #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                     , out float4 outMotionVec : EXTRA_BUFFER_TARGET\n                  #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n              #endif // OUTPUT_SPLIT_LIGHTING\n              #ifdef _DEPTHOFFSET_ON\n                  , out float outputDepth : SV_Depth\n              #endif\n              #if NEED_FACING\n                 , bool facing : SV_IsFrontFace\n              #endif\n          )\n          {\n              #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                 // Init outMotionVector here to solve compiler warning (potentially unitialized variable)\n                 // It is init to the value of forceNoMotion (with 2.0)\n                 outMotionVec = float4(2.0, 0.0, 0.0, 0.0);\n              #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n              FragInputs input = BuildFragInputs(v2p);\n\n              // We need to readapt the SS position as our screen space positions are for a low res buffer, but we try to access a full res buffer.\n              input.positionSS.xy = _OffScreenRendering > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;\n\n              uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();\n\n              // input.positionSS is SV_Position\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex);\n\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n            \n\n              BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n              PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n              outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip lighting when doing debug pass because the debug pass is done before lighting so some buffers may not be properly initialized potentially causing crashes on PS4.\n\n             #ifdef DEBUG_DISPLAY\n                 // Init in debug display mode to quiet warning\n                #ifdef OUTPUT_SPLIT_LIGHTING\n                    outDiffuseLighting = 0;\n                    ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n                #endif\n\n              \n\n              // Same code in ShaderPassForwardUnlit.shader\n              // Reminder: _DebugViewMaterialArray[i]\n              //   i==0 -> the size used in the buffer\n              //   i>0  -> the index used (0 value means nothing)\n              // The index stored in this buffer could either be\n              //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only one supported)\n              //   - a property index which is different for each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n              bool viewMaterial = false;\n              int bufferSize = _DebugViewMaterialArray[0].x;\n              if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                  // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug will do nothing if the index is not a known one\n                  for (int index = 1; index <= bufferSize; index++)\n                  {\n                      int indexMaterialProperty = _DebugViewMaterialArray[index].x;\n\n                      // skip if not really in use\n                      if (indexMaterialProperty != 0)\n                      {\n                          viewMaterial = true;\n\n                          GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                          GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                          GetBuiltinDataDebug(indexMaterialProperty, builtinData, posInput, result, needLinearToSRGB);\n                          GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                          GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                      }\n                  }\n\n                  // TEMP!\n                  // For now, the final blit in the backbuffer performs an sRGB write\n                  // So in the meantime we apply the inverse transform to linear data to compensate.\n                  if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0, result));\n\n                  outColor = float4(result, 1.0);\n              }\n\n              if (!viewMaterial)\n              {\n                  if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData, result);\n\n                      outColor = float4(result, 1.0f);\n                  }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                  {\n                      float4 result = _DebugTransparencyOverdrawWeight * float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                  }\n                  else\n          #endif\n                  {\n          #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                      LightLoopOutput lightLoopOutput;\n                      LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                      float3 diffuseLighting = lightLoopOutput.diffuseLighting;\n                      float3 specularLighting = lightLoopOutput.specularLighting;\n\n                      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                      {\n                          outColor = float4(specularLighting, 1.0);\n                          outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                      }\n                      else\n                      {\n                          outColor = float4(diffuseLighting + specularLighting, 1.0);\n                          outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n          #else\n                      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n          #endif\n\n          ChainFinalColorForward(l, d, outColor);\n\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                      bool forceNoMotion = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec is already initialize at the value of forceNoMotion (see above)\n                      if (!forceNoMotion)\n                      {\n                          float2 motionVec = CalculateMotionVector(v2p.motionVectorCS, v2p.previousPositionCS);\n                          EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                          outMotionVec.zw = 1.0;\n                      }\n          #endif\n                  }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n          #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n          #endif\n\n          #ifdef UNITY_VIRTUAL_TEXTURING\n             outVTFeedback = builtinData.vtPackedFeedback;\n          #endif\n          }\n\n            ENDHLSL\n        }\n               Pass\n        {\n            // based on HDLitPass.template\n            Name \"GBuffer\"\n            Tags { \"LightMode\" = \"GBuffer\" }\n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n                ZTest [_ZTestGBuffer]\n                ColorMask [_LightLayersMaskBuffer4] 4\n                ColorMask [_LightLayersMaskBuffer5] 5\n                Stencil\n                {\n                WriteMask [_StencilWriteMaskGBuffer]\n                Ref [_StencilRefGBuffer]\n                CompFront Always\n                PassFront Replace\n                CompBack Always\n                PassBack Replace\n                }\n\n                ColorMask [_LightLayersMaskBuffer4] 4\n                ColorMask [_LightLayersMaskBuffer5] 5\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n            #pragma target 4.5\n\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n            #pragma multi_compile _ LIGHT_LAYERS\n            //#pragma multi_compile_raytracing _ LIGHT_LAYERS\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT\n                \n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n\n\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_GBUFFER\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define _PASSGBUFFER 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n           \n            //-------------------------------------------------------------------------------------\n            // Defines\n            //-------------------------------------------------------------------------------------\n\n\n            \n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n            void Frag(  VertexToPixel v2f,\n                        OUTPUT_GBUFFER(outGBuffer)\n                        #ifdef _DEPTHOFFSET_ON\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                        )\n            {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n                    #if NEED_FACING\n                      , facing\n                    #endif\n                  );\n\n         \n                  ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);\n\n                  #ifdef _DEPTHOFFSET_ON\n                        outputDepth = l.outputDepth;\n                  #endif\n            }\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"ShadowCaster\"\n            Tags { \"LightMode\" = \"ShadowCaster\" }\n\n            \n\n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n            ZWrite On\n            ColorMask 0\n            ZClip [_ZClip]\n    \n\n               Cull [_CullMode]\n\n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n            //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_SHADOWS\n            #define _PASSSHADOW 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            //-------------------------------------------------------------------------------------\n            // Defines\n            //-------------------------------------------------------------------------------------\n            \n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n    \n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n        \n\n            #if defined(WRITE_NORMAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n               #define SV_TARGET_DECAL SV_Target2\n            #elif defined(WRITE_NORMAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n               #define SV_TARGET_DECAL SV_Target1\n            #else\n               #define SV_TARGET_DECAL SV_Target0\n            #endif\n\n\n              void Frag(  VertexToPixel v2f\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                          , out float4 outColor : SV_Target0\n                          #else\n                          #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color as SV_Target0 for alpha to coverage\n                            , out float4 depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target1\n                                #endif\n                            #else\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target0\n                                #endif\n                            #endif\n\n                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                            , out float4 outDecalBuffer : SV_TARGET_DECAL\n                            #endif\n                        #endif\n\n                        #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n         \n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n                  #ifdef _DEPTHOFFSET_ON\n                     outputDepth = l.outputDepth;\n                  #endif\n\n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2f.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  #endif\n\n                   #if defined(WRITE_NORMAL_BUFFER)\n                      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                   #endif\n\n                   #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                      DecalPrepassData decalPrepassData;\n                      // We don't have the right to access SurfaceData in a shaderpass.\n                      // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                      // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                      decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                      decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                      EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                   #endif\n\n\n              }\n\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"DepthOnly\"\n            Tags { \"LightMode\" = \"DepthOnly\" }\n            \n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n        \n            \n            ZWrite On\n        \n            \n            // Stencil setup\n        Stencil\n        {\n           WriteMask [_StencilWriteMaskDepth]\n           Ref [_StencilRefDepth]\n           CompFront Always\n           PassFront Replace\n           CompBack Always\n           PassBack Replace\n        }\n        AlphaToMask [_AlphaCutoffEnable]\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n            #pragma multi_compile _ WRITE_MSAA_DEPTH\n            #define _PASSDEPTH 1\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n              #if defined(WRITE_NORMAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n              #define SV_TARGET_DECAL SV_Target2\n              #elif defined(WRITE_NORMAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n              #define SV_TARGET_DECAL SV_Target1\n              #else\n              #define SV_TARGET_DECAL SV_Target0\n              #endif\n\n\n              void Frag(  VertexToPixel v2p\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                            , out float4 outColor : SV_Target0\n                            #else\n                                #ifdef WRITE_MSAA_DEPTH\n                                // We need the depth color as SV_Target0 for alpha to coverage\n                                , out float4 depthColor : SV_Target0\n                                    #ifdef WRITE_NORMAL_BUFFER\n                                    , out float4 outNormalBuffer : SV_Target1\n                                    #endif\n                                #else\n                                    #ifdef WRITE_NORMAL_BUFFER\n                                    , out float4 outNormalBuffer : SV_Target0\n                                    #endif\n                                #endif\n\n                                // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                                #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                                , out float4 outDecalBuffer : SV_TARGET_DECAL\n                                #endif\n                            #endif\n\n                            #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)\n                            , out float outputDepth : DEPTH_OFFSET_SEMANTIC\n                            #endif\n                             #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n                  FragInputs input = BuildFragInputs(v2p);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n                  // to prevent stripping\n                  surfaceData.normalWS *= saturate(l.Albedo.r + 9999);\n\n                  #ifdef _DEPTHOFFSET_ON\n                     outputDepth = l.outputDepth;\n                  #endif\n\n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = unity_SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                     #endif\n\n                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                        DecalPrepassData decalPrepassData;\n                        // We don't have the right to access SurfaceData in a shaderpass.\n                        // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                        // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                        decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                     #endif\n                  #endif\n\n              }\n\n\n\n         ENDHLSL\n    }\n\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"META\"\n            Tags { \"LightMode\" = \"META\" }\n            \n            Cull Off\n        \n               Cull [_CullMode]\n\n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n\n        \n            #pragma multi_compile_instancing\n\n            //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define REQUIRE_DEPTH_TEXTURE\n            #define _PASSMETA 1\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n        \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n\n            \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n            float4 Frag(VertexToPixel v2f\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n            {\n                FragInputs input = BuildFragInputs(v2f);\n\n                // input.positionSS is SV_Position\n                PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n                SurfaceData surfaceData;\n                BuiltinData builtinData;\n                Surface l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n                // no debug apply during light transport pass\n\n                BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n                LightTransportData lightTransportData = GetLightTransportData(surfaceData, builtinData, bsdfData);\n\n                // This shader is call two times. Once for getting emissiveColor, the other time to get diffuseColor\n                // We use unity_MetaFragmentControl to make the distinction.\n                float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n                {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                    // put abs here to silent a warning, no cost, no impact as color is assume to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor), saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n                }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                    // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n                }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\" }\n        \n            Cull Off\n            ColorMask 0\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n            #pragma instancing_options renderinglayer\n        \n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define SCENESELECTIONPASS\n            #define _PASSSCENESELECT 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            \n\n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n        \n\n            \n            void Frag(  VertexToPixel IN\n            #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_Target0\n                #ifdef WRITE_MSAA_DEPTH\n                , out float1 depthColor : SV_Target1\n                #endif\n            #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth, but we still have normal buffer binded\n            , out float4 outNormalBuffer : SV_Target0\n            , out float1 depthColor : SV_Target1\n            #elif defined(SCENESELECTIONPASS)\n            , out float4 outColor : SV_Target0\n            #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n        )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n             FragInputs input = BuildFragInputs(IN);\n\n             // input.positionSS is SV_Position\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n\n             float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n            SurfaceData surfaceData;\n            BuiltinData builtinData;\n            Surface l;\n            ShaderData d;\n            GetSurfaceAndBuiltinData(IN, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = l.outputDepth;\n         #endif\n\n         #ifdef WRITE_NORMAL_BUFFER\n             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS, outNormalBuffer);\n             #ifdef WRITE_MSAA_DEPTH\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n             #endif\n         #elif defined(WRITE_MSAA_DEPTH) // When we are MSAA depth only without normal buffer\n             // Due to the binding order of these two render targets, we need to have them both declared\n             outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n         #elif defined(SCENESELECTIONPASS)\n             // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n             outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n         #endif\n         }\n\n         ENDHLSL\n     }\n\n        \n              Pass\n        {\n            Name \"ScenePickingPass\"\n            Tags\n            {\n               \"LightMode\" = \"Picking\"\n            }\n            \n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n            #pragma instancing_options renderinglayer\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENEPICKINGPASS\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n            void Frag( VertexToPixel v2f\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                          , out float4 outColor : SV_Target0\n                          #else\n                          #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color as SV_Target0 for alpha to coverage\n                            , out float4 depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target1\n                                #endif\n                            #else\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target0\n                                #endif\n                            #endif\n\n                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                            , out float4 outDecalBuffer : SV_TARGET_DECAL\n                            #endif\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n                  \n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                     #endif\n\n                     #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                        DecalPrepassData decalPrepassData;\n                        // We don't have the right to access SurfaceData in a shaderpass.\n                        // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                        // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                        decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                        decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                     #endif\n                  #endif\n\n\n              }\n\n         ENDHLSL\n        }\n\n              Pass\n        {\n            Name \"MotionVectors\"\n            Tags\n            {\n               \"LightMode\" = \"MotionVectors\"\n            }\n    \n            // Render State\n            Cull Back\n            ZWrite On\n            Stencil\n               {\n                  WriteMask [_StencilWriteMaskMV]\n                  Ref [_StencilRefMV]\n                  CompFront Always\n                  PassFront Replace\n                  CompBack Always\n                  PassBack Replace\n               }\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n\n            #pragma multi_compile _ WRITE_MSAA_DEPTH\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n\n            #define SHADERPASS SHADERPASS_MOTION_VECTORS\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define VARYINGS_NEED_PASS\n            #define _PASSMOTIONVECTOR 1\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n#if defined(WRITE_DECAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n#define SV_TARGET_NORMAL SV_Target3\n#elif defined(WRITE_DECAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n#define SV_TARGET_NORMAL SV_Target2\n#else\n#define SV_TARGET_NORMAL SV_Target1\n#endif\n\n// Caution: Motion vector pass is different from Depth prepass, it render normal buffer last instead of decal buffer last\n// and thus, we force a write of 0 if _DISABLE_DECALS so we always write in the decal buffer.\n// This is required as we can't make distinction  between deferred (write normal buffer) and forward (write normal buffer)\n// in the context of the motion vector pass. The cost is acceptable as it is only do object with motion vector (usualy skin object)\n// that most of the time use Forward Material (so are already writing motion vector data).\n// So note that here unlike for depth prepass we don't check && !defined(_DISABLE_DECALS)\nvoid Frag(  VertexToPixel v2f\n            #ifdef WRITE_MSAA_DEPTH\n            // We need the depth color as SV_Target0 for alpha to coverage\n            , out float4 depthColor : SV_Target0\n            , out float4 outMotionVector : SV_Target1\n                #ifdef WRITE_DECAL_BUFFER\n                , out float4 outDecalBuffer : SV_Target2\n                #endif\n            #else\n            // When no MSAA, the motion vector is always the first buffer\n            , out float4 outMotionVector : SV_Target0\n                #ifdef WRITE_DECAL_BUFFER\n                , out float4 outDecalBuffer : SV_Target1\n                #endif\n            #endif\n\n            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n            #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_TARGET_NORMAL\n            #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n        )\n          {\n\n              FragInputs input = BuildFragInputs(v2f);\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n            #ifdef _DEPTHOFFSET_ON\n                v2f.motionVectorCS.w += builtinData.depthOffset;\n                v2f.previousPositionCS.w += builtinData.depthOffset;\n            #endif\n\n             // TODO: How to allow overriden motion vector from GetSurfaceAndBuiltinData ?\n             float2 motionVector = CalculateMotionVector(v2f.motionVectorCS, v2f.previousPositionCS);\n\n             // Convert from Clip space (-1..1) to NDC 0..1 space.\n             // Note it doesn't mean we don't have negative value, we store negative or positive offset in NDC space.\n             // Note: ((positionCS * 0.5 + 0.5) - (v2f.previousPositionCS * 0.5 + 0.5)) = (motionVector * 0.5)\n             EncodeMotionVector(motionVector * 0.5, outMotionVector);\n\n             // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n             bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n             // Setting the motionVector to a value more than 2 set as a flag for \"force no motion\". This is valid because, given that the velocities are in NDC,\n             // a value of >1 can never happen naturally, unless explicitely set. \n             if (forceNoMotion)\n                 outMotionVector = float4(2.0, 0.0, 0.0, 0.0);\n\n         // Depth and Alpha to coverage\n         #ifdef WRITE_MSAA_DEPTH\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n\n             #ifdef _ALPHATOMASK_ON\n             // Alpha channel is used for alpha to coverage\n             depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n             #endif\n         #endif\n\n         // Normal Buffer Processing\n         #ifdef WRITE_NORMAL_BUFFER\n             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n         #endif\n\n         #if defined(WRITE_DECAL_BUFFER)\n             DecalPrepassData decalPrepassData;\n             // Force a write in decal buffer even if decal is disab. This is a neutral value which have no impact for later pass\n             #ifdef _DISABLE_DECALS\n             ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);\n             #else\n             // We don't have the right to access SurfaceData in a shaderpass.\n             // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n             // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n             decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n             decalPrepassData.decalLayerMask = GetMeshRenderingDecalLayer();\n             #endif\n             EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n             outDecalBuffer.w = (GetMeshRenderingLightLayer() & 0x000000FF) / 255.0;\n         #endif\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = posInput.deviceDepth;\n         #endif\n          }\n\n            ENDHLSL\n        }\n\n      \n              Pass\n        {\n            Name \"FullScreenDebug\"\n            Tags\n            {\n               \"LightMode\" = \"FullScreenDebug\"\n            }\n    \n            // Render State\n            Cull Back\n            ZTest LEqual\n            ZWrite Off\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                #pragma multi_compile _ LOD_FADE_CROSSFADE\n        \n\n            #define SHADERPASS SHADERPASS_FULL_SCREEN_DEBUG\n            #define _PASSFULLSCREENDEBUG 1\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/NormalBuffer.hlsl\"\n\n#if UNITY_VERSION >= 202239\n        #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n#else\n        #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphHeader.hlsl\" \n#endif          \n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n#define DEBUG_DISPLAY\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl\"\n\n         #if !defined(_DEPTHOFFSET_ON)\n         [earlydepthstencil] // quad overshading debug mode writes to UAV\n         #endif\n         void Frag(VertexToPixel v2f\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n             FragInputs input = BuildFragInputs(v2f);\n\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz);\n\n         #ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER\n             if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)\n             {\n                 IncrementQuadOverdrawCounter(posInput.positionSS.xy, input.primitiveID);\n             }\n         #endif\n         }\n\n            ENDHLSL\n        }\n\n      \n\n\n      \n   }\n\n   \n   \n   \n}\n"},{"srpTarget":1,"UnityVersionMin":20222,"UnityVersionMax":20233,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2021.3.38f1\n//   Render Pipeline: URP2022\n//   Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader \"UMA/Diffuse_Normal_Metallic\"\n{\n   Properties\n   {\n      [HideInInspector]_QueueOffset(\"_QueueOffset\", Float) = 0\n      [HideInInspector]_QueueControl(\"_QueueControl\", Float) = -1\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\", 2DArray) = \"\" {}\n      \n\n    [BetterHeader(Material Specific)]\n    _Color (\"Main Color\", Color) = (1, 1, 1, 1)\n\t_ColorModulation (\"Color Modulation\", Range(0,2)) = 1\n\t_MetallicModulation (\"Metallic Level\", Range(0,2)) = 1\n\t_SmoothnessModulation (\"Smoothness Level\", Range(0,2)) = 1\n\t[BetterHeader(Lighting Adjustment)]\n    [Toggle]_UseHalfLambert (\"Use Half Lambert\", Float) = 0\n    _HalfLambertStrength (\"Lambert(0), HalfLambert(1)\", Range(0,16)) = 1\n    _RimLightingModulation (\"Rim Lighting Level\", Float) = 0\n\t_RimLightColor(\"Rim Light Color\", Color) = (1,1,1,1)\n\t_RimLightPower(\"Rim Light Power\", Range(0.5, 12)) = 4\n\n    [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n    [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n    _BaseMap(\"BaseMap\", 2D) = \"white\" {}\n    _BumpMap(\"_BumpMap\", 2D) = \"bump\" {}\n    _NormalStrength (\"Normal Strength\", Range(0,2)) = 1\n    _MetallicGlossMap(\"_MetallicGlossMap\", 2D) = \"black\" {}\n    _UberTile(\"Uber Tile\", Range(0,16)) = 1\n\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\" \"RenderType\" = \"Opaque\" \"UniversalMaterialType\" = \"Lit\" \"Queue\" = \"Geometry\" }\n\n      \n\n      \n        Pass\n        {\n            Name \"Universal Forward\"\n            Tags \n            { \n                \"LightMode\" = \"UniversalForward\"\n            }\n            Cull Back\n            Blend One Zero\n            ZTest LEqual\n            ZWrite On\n\n            Blend One Zero, One Zero\nCull Back\nZTest LEqual\nZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n    \n            // Keywords\n            #pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\n            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS\n            #pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT\n            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3\n            #pragma multi_compile_fragment _ _LIGHT_LAYERS\n            #pragma multi_compile_fragment _ DEBUG_DISPLAY\n            #pragma multi_compile_fragment _ _LIGHT_COOKIES\n            #pragma multi_compile_fragment _ _WRITE_RENDERING_LAYERS\n            #pragma multi_compile _ _FORWARD_PLUS\n            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE\n        \n            // GraphKeywords: <None>\n\n            #define SHADER_PASS SHADERPASS_FORWARD\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define _PASSFORWARD 1\n            #define _FOG_FRAGMENT 1\n            \n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DBuffer.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl\"\n            \n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n         \n\n#if _UNLIT\n   #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Unlit.hlsl\"  \n#endif\n\n         // fragment shader\n         void Frag (VertexToPixel IN\n              , out half4 outColor : SV_Target0\n            #ifdef _WRITE_RENDERING_LAYERS\n              , out float4 outRenderingLayers : SV_Target1\n            #endif\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         )\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           #if defined(LOD_FADE_CROSSFADE)\n              LODFadeCrossFade(IN.pos);\n           #endif\n\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n           #if _USESPECULAR || _SIMPLELIT\n              float3 specular = l.Specular;\n              float metallic = 1;\n           #else   \n              float3 specular = 0;\n              float metallic = l.Metallic;\n           #endif\n\n\n            \n           \n            InputData inputData = (InputData)0;\n\n            inputData.positionWS = IN.worldPos;\n            #if _WORLDSPACENORMAL\n              inputData.normalWS = l.Normal;\n            #else\n              inputData.normalWS = normalize(TangentToWorldSpace(d, l.Normal));\n            #endif\n\n            inputData.viewDirectionWS = SafeNormalize(d.worldSpaceViewDir);\n\n\n            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n                  inputData.shadowCoord = IN.shadowCoord;\n            #elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                  inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n            #else\n                  inputData.shadowCoord = float4(0, 0, 0, 0);\n            #endif\n            \n#if _BAKEDLIT\n            inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n            inputData.vertexLighting = 0;\n#else\n            inputData.fogCoord = InitializeInputDataFog(float4(IN.worldPos, 1.0), IN.fogFactorAndVertexLight.x);\n            inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n#endif    \n\n\n\n            #if defined(_OVERRIDE_BAKEDGI)\n               inputData.bakedGI = l.DiffuseGI;\n               l.Emission += l.SpecularGI;\n            #elif _BAKEDLIT\n               inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n            #else\n               #if defined(DYNAMICLIGHTMAP_ON)\n                  inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.dynamicLightmapUV.xy, IN.sh, inputData.normalWS);\n               #else\n                  inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n               #endif\n            #endif\n            inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n            #if !_BAKEDLIT\n               inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n           \n               #if defined(_OVERRIDE_SHADOWMASK)\n                  float4 mulColor = saturate(dot(l.ShadowMask, _MainLightOcclusionProbes)); //unity_OcclusionMaskSelector));\n                  inputData.shadowMask = mulColor;\n               #endif\n            #else\n               inputData.shadowMask = float4(1,1,1,1);\n            #endif\n\n            #if defined(DEBUG_DISPLAY)\n                #if defined(DYNAMICLIGHTMAP_ON)\n                  inputData.dynamicLightmapUV = IN.dynamicLightmapUV.xy;\n                #endif\n                #if defined(LIGHTMAP_ON)\n                  inputData.staticLightmapUV = IN.lightmapUV;\n                #else\n                  inputData.vertexSH = IN.sh;\n                #endif\n            #endif\n\n            #if _WORLDSPACENORMAL\n              float3 normalTS = WorldToTangentSpace(d, l.Normal);\n            #else\n              float3 normalTS = l.Normal;\n            #endif\n\n            SurfaceData surface         = (SurfaceData)0;\n            surface.albedo              = l.Albedo;\n            surface.metallic            = saturate(metallic);\n            surface.specular            = specular;\n            surface.smoothness          = saturate(l.Smoothness),\n            surface.occlusion           = l.Occlusion,\n            surface.emission            = l.Emission,\n            surface.alpha               = saturate(l.Alpha);\n            surface.clearCoatMask       = 0;\n            surface.clearCoatSmoothness = 1;\n\n            #ifdef _CLEARCOAT\n                  surface.clearCoatMask       = saturate(l.CoatMask);\n                  surface.clearCoatSmoothness = saturate(l.CoatSmoothness);\n            #endif\n\n            #if !_UNLIT\n               half4 color = half4(l.Albedo, l.Alpha);\n               #ifdef _DBUFFER\n                  #if _BAKEDLIT\n                     half3 bakeColor = color.rgb;\n                     float3 bakeNormal = inputData.normalWS.xyz;\n                     ApplyDecalToBaseColorAndNormal(IN.pos, bakeColor, bakeNormal);\n                     color.rgb = bakeColor;\n                     inputData.normalWS.xyz = bakeNormal;\n                  #else\n                     ApplyDecalToSurfaceData(IN.pos, surface, inputData);\n                  #endif\n               #endif\n               #if _SIMPLELIT\n                  color = UniversalFragmentBlinnPhong(\n                     inputData,\n                     surface);\n               #elif _BAKEDLIT\n                  color = UniversalFragmentBakedLit(inputData, color.rgb, color.a, normalTS);\n               #else\n                  color = UniversalFragmentPBR(inputData, surface);\n               #endif\n\n               #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n               #endif\n\n            #else // unlit\n               #ifdef _DBUFFER\n                  ApplyDecalToSurfaceData(IN.pos, surface, inputData);\n               #endif\n               half4 color = UniversalFragmentUnlit(inputData, l.Albedo, l.Alpha);\n               #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n               #endif\n            #endif\n            ChainFinalColorForward(l, d, color);\n\n            outColor = color;\n\n            #ifdef _WRITE_RENDERING_LAYERS\n                uint renderingLayers = GetMeshRenderingLayer();\n                outRenderingLayers = float4(EncodeMeshRenderingLayer(renderingLayers), 0, 0, 0);\n            #endif\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"GBuffer\"\n            Tags\n            {\n               \"LightMode\" = \"UniversalGBuffer\"\n            }\n           \n             Blend One Zero\n             ZTest LEqual\n             ZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n            #pragma multi_compile_fog\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            \n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT\n            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE\n            #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3\n            #pragma multi_compile_fragment _ _GBUFFER_NORMALS_OCT\n            #pragma multi_compile_fragment _ _WRITE_RENDERING_LAYERS\n            #pragma multi_compile_fragment _ _RENDER_PASS_ENABLED\n            #pragma multi_compile_fragment _ DEBUG_DISPLAY\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE\n        \n\n            #define _FOG_FRAGMENT 1\n\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define SHADERPASS SHADERPASS_GBUFFER\n            #define _PASSGBUFFER 1\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            \n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DBuffer.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl\"\n            \n\n            \n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityGBuffer.hlsl\"\n\n            // fragment shader\n            FragmentOutput Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) \n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n               #if defined(LOD_FADE_CROSSFADE)\n                  LODFadeCrossFade(IN.pos);\n               #endif\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n               #if _USESPECULAR || _SIMPLELIT\n                  float3 specular = l.Specular;\n                  float metallic = 0;\n               #else   \n                  float3 specular = 0;\n                  float metallic = l.Metallic;\n               #endif\n\n               InputData inputData = (InputData)0;\n\n               inputData.positionWS = IN.worldPos;\n               #if _WORLDSPACENORMAL\n                  inputData.normalWS = l.Normal;\n               #else\n                  inputData.normalWS = normalize(TangentToWorldSpace(d, l.Normal));\n               #endif\n\n               inputData.viewDirectionWS = SafeNormalize(d.worldSpaceViewDir);\n\n\n               #if defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                   inputData.shadowCoord = TransformWorldToShadowCoord(inputData.positionWS);\n               #else\n                   inputData.shadowCoord = float4(0, 0, 0, 0);\n               #endif\n\n               //inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n               InitializeInputDataFog(float4(IN.worldPos, 1.0), IN.fogFactorAndVertexLight.x);\n               inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n\n\n               #if defined(_OVERRIDE_BAKEDGI)\n                  inputData.bakedGI = l.DiffuseGI;\n                  l.Emission += l.SpecularGI;\n               #else\n                  #if defined(DYNAMICLIGHTMAP_ON)\n                   inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.dynamicLightmapUV.xy, IN.sh, inputData.normalWS);\n                  #else\n                      inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n                  #endif\n               #endif\n\n               inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n               inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n\n               #if defined(DEBUG_DISPLAY)\n                   #if defined(DYNAMICLIGHTMAP_ON)\n                     inputData.dynamicLightmapUV = IN.dynamicLightmapUV.xy;\n                   #endif\n                   #if defined(LIGHTMAP_ON)\n                     inputData.staticLightmapUV = IN.lightmapUV;\n                   #else\n                     inputData.vertexSH = IN.sh;\n                   #endif\n               #endif\n\n               #ifdef _DBUFFER\n                   ApplyDecal(IN.pos,\n                       l.Albedo,\n                       specular,\n                       inputData.normalWS,\n                       metallic,\n                       l.Occlusion,\n                       l.Smoothness);\n               #endif\n\n               BRDFData brdfData;\n               InitializeBRDFData(l.Albedo, metallic, specular, l.Smoothness, l.Alpha, brdfData);\n               Light mainLight = GetMainLight(inputData.shadowCoord, inputData.positionWS, inputData.shadowMask);\n               MixRealtimeAndBakedGI(mainLight, inputData.normalWS, inputData.bakedGI, inputData.shadowMask);\n               half3 color = GlobalIllumination(brdfData, inputData.bakedGI, l.Occlusion, inputData.positionWS, inputData.normalWS, inputData.viewDirectionWS);\n\n               return BRDFDataToGbuffer(brdfData, inputData, l.Smoothness, l.Emission + color, l.Occlusion);\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"ShadowCaster\"\n            Tags \n            { \n                \"LightMode\" = \"ShadowCaster\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n  \n            #pragma multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW\n            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE\n        \n\n            #define _NORMAL_DROPOFF_TS 1\n            #define ATTRIBUTES_NEED_NORMAL\n            #define ATTRIBUTES_NEED_TANGENT\n            #define _PASSSHADOW 1\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n                 \n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl\"\n            \n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n         \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               #if defined(LOD_FADE_CROSSFADE)\n                  LODFadeCrossFade(IN.pos);\n               #endif\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n             return 0;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"DepthOnly\"\n            Tags \n            { \n                \"LightMode\" = \"DepthOnly\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            ColorMask 0\n            \n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n\n            #define _PASSDEPTH 1\n\n            #pragma target 3.0\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n         \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n                #if defined(LOD_FADE_CROSSFADE) && USE_UNITY_CROSSFADE\n                    LODFadeCrossFade(IN.pos);\n                #endif\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n               return 0;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"Meta\"\n            Tags \n            { \n                \"LightMode\" = \"Meta\"\n            }\n\n            Cull Off\n            \n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n        \n            #define SHADERPASS SHADERPASS_META\n            #define _PASSMETA 1\n\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n\n               Surface l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n               metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"DepthNormals\"\n            Tags\n            {\n               \"LightMode\" = \"DepthNormals\"\n            }\n    \n            // Render State\n             Cull Back\n                ZTest LEqual\n                ZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE\n            #pragma multi_compile_fragment _ _WRITE_RENDERING_LAYERS\n        \n\n            #define SHADERPASS SHADERPASS_DEPTHNORMALSONLY\n            #define _PASSDEPTH 1\n            #define _PASSDEPTHNORMALS 1\n\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Version.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl\"\n            \n\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           \n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n\n#if !_TESSELLATION_ON\n           ChainModifyVertex(v, o, _Time);\n#endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = TransformObjectToWorld(v.vertex.xyz);\n           o.worldNormal = TransformObjectToWorldNormal(v.normal);\n           o.worldTangent = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              OUTPUT_SH(o.worldNormal, o.sh);\n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n           return o;\n         }\n\n\n         \n\n         // fragment shader\n         void Frag (VertexToPixel IN\n            , out half4 outNormalWS : SV_Target0\n         #ifdef _WRITE_RENDERING_LAYERS\n            , out float4 outRenderingLayers : SV_Target1\n         #endif\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         )\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           #if defined(LOD_FADE_CROSSFADE)\n              LODFadeCrossFade(IN.pos);\n           #endif\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n          #if defined(_GBUFFER_NORMALS_OCT)\n              float3 normalWS = d.worldSpaceNormal;\n              float2 octNormalWS = PackNormalOctQuadEncode(normalWS);           // values between [-1, +1], must use fp32 on some platforms\n              float2 remappedOctNormalWS = saturate(octNormalWS * 0.5 + 0.5);   // values between [ 0,  1]\n              half3 packedNormalWS = PackFloat2To888(remappedOctNormalWS);      // values between [ 0,  1]\n              outNormalWS = half4(packedNormalWS, 0.0);\n          #else\n              float3 wsn = l.Normal;\n              #if !_WORLDSPACENORMAL\n                wsn = TangentToWorldSpace(d, l.Normal);\n              #endif\n              outNormalWS = half4(NormalizeNormalPerPixel(wsn), 0.0);\n          #endif\n\n          #ifdef _WRITE_RENDERING_LAYERS\n            uint renderingLayers = GetMeshRenderingLayer();\n            outRenderingLayers = float4(EncodeMeshRenderingLayer(renderingLayers), 0, 0, 0);\n          #endif\n\n         \n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n\n\n      \n\n   }\n   \n   \n   \n}\n"},{"srpTarget":2,"UnityVersionMin":20233,"UnityVersionMax":30000,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2021.3.38f1\n//   Render Pipeline: HDRP2023\n//   Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader \"UMA/Diffuse_Normal_Metallic\"\n{\n   Properties\n   {\n      \n\n    [BetterHeader(Material Specific)]\n    _Color (\"Main Color\", Color) = (1, 1, 1, 1)\n\t_ColorModulation (\"Color Modulation\", Range(0,2)) = 1\n\t_MetallicModulation (\"Metallic Level\", Range(0,2)) = 1\n\t_SmoothnessModulation (\"Smoothness Level\", Range(0,2)) = 1\n\t[BetterHeader(Lighting Adjustment)]\n    [Toggle]_UseHalfLambert (\"Use Half Lambert\", Float) = 0\n    _HalfLambertStrength (\"Lambert(0), HalfLambert(1)\", Range(0,16)) = 1\n    _RimLightingModulation (\"Rim Lighting Level\", Float) = 0\n\t_RimLightColor(\"Rim Light Color\", Color) = (1,1,1,1)\n\t_RimLightPower(\"Rim Light Power\", Range(0.5, 12)) = 4\n\n    [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n    [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n    _BaseMap(\"BaseMap\", 2D) = \"white\" {}\n    _BumpMap(\"_BumpMap\", 2D) = \"bump\" {}\n    _NormalStrength (\"Normal Strength\", Range(0,2)) = 1\n    _MetallicGlossMap(\"_MetallicGlossMap\", 2D) = \"black\" {}\n    _UberTile(\"Uber Tile\", Range(0,16)) = 1\n\n\n\n\n      [HideInInspector]_RenderQueueType(\"Float\", Float) = 1\n      [HideInInspector][ToggleUI]_AddPrecomputedVelocity(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_DepthOffsetEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentWritingMotionVec(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaCutoffEnable(\"Boolean\", Float) = 0\n      [HideInInspector]_TransparentSortPriority(\"_TransparentSortPriority\", Float) = 0\n      [HideInInspector][ToggleUI]_UseShadowThreshold(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPrepassEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_TransparentDepthPostpassEnable(\"Boolean\", Float) = 0\n      [HideInInspector]_SurfaceType(\"Float\", Float) = 0\n      [HideInInspector]_BlendMode(\"Float\", Float) = 0\n      [HideInInspector]_SrcBlend(\"Float\", Float) = 1\n      [HideInInspector]_DstBlend(\"Float\", Float) = 0\n      [HideInInspector]_AlphaSrcBlend(\"Float\", Float) = 1\n      [HideInInspector]_AlphaDstBlend(\"Float\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMask(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_AlphaToMaskInspectorValue(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_ZWrite(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_TransparentZWrite(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_EnableFogOnTransparent(\"Boolean\", Float) = 1\n      [HideInInspector]_ZTestDepthEqualForOpaque(\"Float\", Int) = 4\n      [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)]_ZTestTransparent(\"Float\", Float) = 4\n      [HideInInspector][ToggleUI]_TransparentBackfaceEnable(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_RequireSplitLighting(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_ReceivesSSR(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_ReceivesSSRTransparent(\"Boolean\", Float) = 0\n      [HideInInspector][ToggleUI]_EnableBlendModePreserveSpecularLighting(\"Boolean\", Float) = 1\n      [HideInInspector][ToggleUI]_SupportDecals(\"Boolean\", Float) = 1\n      [HideInInspector]_StencilRef(\"Float\", Int) = 0\n      [HideInInspector]_StencilWriteMask(\"Float\", Int) = 6\n      [HideInInspector]_StencilRefDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilWriteMaskDepth(\"Float\", Int) = 8\n      [HideInInspector]_StencilRefMV(\"Float\", Int) = 40\n      [HideInInspector]_StencilWriteMaskMV(\"Float\", Int) = 40\n      [HideInInspector]_StencilRefDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskDistortionVec(\"Float\", Int) = 4\n      [HideInInspector]_StencilWriteMaskGBuffer(\"Float\", Int) = 14\n      [HideInInspector]_StencilRefGBuffer(\"Float\", Int) = 10\n      [HideInInspector]_ZTestGBuffer(\"Float\", Int) = 4\n      [HideInInspector][ToggleUI]_RayTracing(\"Boolean\", Float) = 0\n      [HideInInspector][Enum(None, 0, Box, 1, Sphere, 2, Thin, 3)]_RefractionModel(\"Float\", Float) = 0\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\", 2DArray) = \"\" {}\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\" = \"HDRenderPipeline\" \"RenderType\" = \"HDLitShader\" \"Queue\" = \"Geometry+225\" }\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"Forward\"\n            Tags { \"LightMode\" = \"Forward\" }\n\n            \n            \n            Stencil\n            {\n               WriteMask [_StencilWriteMask]\n               Ref [_StencilRef]\n               CompFront Always\n               PassFront Replace\n               CompBack Always\n               PassBack Replace\n            }\n        \n            ColorMask [_ColorMaskTransparentVel] 1\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n\n            #pragma target 4.5\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n            \n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT\n            #pragma multi_compile_fragment SHADOW_LOW SHADOW_MEDIUM SHADOW_HIGH\n            #pragma multi_compile_fragment SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON\n            #pragma multi_compile_fragment USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST\n            #pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n            #pragma multi_compile _ USE_LEGACY_LIGHTMAPS\n\n                 \n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_FORWARD\n            #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING\n            #define HAS_LIGHTLOOP\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define _PASSFORWARD 1\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n            #ifdef UNITY_VIRTUAL_TEXTURING\n            #define VT_BUFFER_TARGET SV_Target1\n            #define EXTRA_BUFFER_TARGET SV_Target2\n            #else\n            #define EXTRA_BUFFER_TARGET SV_Target1\n            #endif\n\n\n\n\n          void Frag(VertexToPixel v2p,\n              #ifdef OUTPUT_SPLIT_LIGHTING\n                  out float4 outColor : SV_Target0,  // outSpecularLighting\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                      out float4 outVTFeedback : VT_BUFFER_TARGET,\n                  #endif\n                  out float4 outDiffuseLighting : EXTRA_BUFFER_TARGET,\n                  OUTPUT_SSSBUFFER(outSSSBuffer)\n              #else\n                  out float4 outColor : SV_Target0\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                      ,out float4 outVTFeedback : VT_BUFFER_TARGET\n                  #endif\n                  #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                     , out float4 outMotionVec : EXTRA_BUFFER_TARGET\n                  #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n              #endif // OUTPUT_SPLIT_LIGHTING\n              #ifdef _DEPTHOFFSET_ON\n                  , out float outputDepth : SV_Depth\n              #endif\n              #if NEED_FACING\n                 , bool facing : SV_IsFrontFace\n              #endif\n          )\n          {\n              #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                 // Init outMotionVector here to solve compiler warning (potentially unitialized variable)\n                 // It is init to the value of forceNoMotion (with 2.0)\n                 outMotionVec = float4(2.0, 0.0, 0.0, 0.0);\n              #endif\n\n              UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n              FragInputs input = BuildFragInputs(v2p);\n\n              // We need to readapt the SS position as our screen space positions are for a low res buffer, but we try to access a full res buffer.\n              input.positionSS.xy = _OffScreenRendering > 0 ? (input.positionSS.xy * _OffScreenDownsampleFactor) : input.positionSS.xy;\n\n              uint2 tileIndex = uint2(input.positionSS.xy) / GetTileSize();\n\n              // input.positionSS is SV_Position\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz, tileIndex);\n\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n            \n\n              BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n\n              PreLightData preLightData = GetPreLightData(V, posInput, bsdfData);\n\n              outColor = float4(0.0, 0.0, 0.0, 0.0);\n\n              // We need to skip lighting when doing debug pass because the debug pass is done before lighting so some buffers may not be properly initialized potentially causing crashes on PS4.\n\n             #ifdef DEBUG_DISPLAY\n                 // Init in debug display mode to quiet warning\n                #ifdef OUTPUT_SPLIT_LIGHTING\n                    outDiffuseLighting = 0;\n                    ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n                #endif\n\n              \n\n              // Same code in ShaderPassForwardUnlit.shader\n              // Reminder: _DebugViewMaterialArray[i]\n              //   i==0 -> the size used in the buffer\n              //   i>0  -> the index used (0 value means nothing)\n              // The index stored in this buffer could either be\n              //   - a gBufferIndex (always stored in _DebugViewMaterialArray[1] as only one supported)\n              //   - a property index which is different for each kind of material even if reflecting the same thing (see MaterialSharedProperty)\n              bool viewMaterial = false;\n              int bufferSize = _DebugViewMaterialArray[0].x;\n              if (bufferSize != 0)\n              {\n                  bool needLinearToSRGB = false;\n                  float3 result = float3(1.0, 0.0, 1.0);\n\n                  // Loop through the whole buffer\n                  // Works because GetSurfaceDataDebug will do nothing if the index is not a known one\n                  for (int index = 1; index <= bufferSize; index++)\n                  {\n                      int indexMaterialProperty = _DebugViewMaterialArray[index].x;\n\n                      // skip if not really in use\n                      if (indexMaterialProperty != 0)\n                      {\n                          viewMaterial = true;\n\n                          GetPropertiesDataDebug(indexMaterialProperty, result, needLinearToSRGB);\n                          GetVaryingsDataDebug(indexMaterialProperty, input, result, needLinearToSRGB);\n                          GetBuiltinDataDebug(indexMaterialProperty, builtinData, posInput, result, needLinearToSRGB);\n                          GetSurfaceDataDebug(indexMaterialProperty, surfaceData, result, needLinearToSRGB);\n                          GetBSDFDataDebug(indexMaterialProperty, bsdfData, result, needLinearToSRGB);\n                      }\n                  }\n\n                  // TEMP!\n                  // For now, the final blit in the backbuffer performs an sRGB write\n                  // So in the meantime we apply the inverse transform to linear data to compensate.\n                  if (!needLinearToSRGB)\n                      result = SRGBToLinear(max(0, result));\n\n                  outColor = float4(result, 1.0);\n              }\n\n              if (!viewMaterial)\n              {\n                  if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_DIFFUSE_COLOR || _DebugFullScreenMode == FULLSCREENDEBUGMODE_VALIDATE_SPECULAR_COLOR)\n                  {\n                      float3 result = float3(0.0, 0.0, 0.0);\n\n                      GetPBRValidatorDebug(surfaceData, result);\n\n                      outColor = float4(result, 1.0f);\n                  }\n                  else if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_TRANSPARENCY_OVERDRAW)\n                  {\n                      float4 result = _DebugTransparencyOverdrawWeight * float4(TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_COST, TRANSPARENCY_OVERDRAW_A);\n                      outColor = result;\n                  }\n                  else\n          #endif\n                  {\n          #ifdef _SURFACE_TYPE_TRANSPARENT\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_TRANSPARENT;\n          #else\n                      uint featureFlags = LIGHT_FEATURE_MASK_FLAGS_OPAQUE;\n          #endif\n\n                      LightLoopOutput lightLoopOutput;\n                      LightLoop(V, posInput, preLightData, bsdfData, builtinData, featureFlags, lightLoopOutput);\n\n                      float3 diffuseLighting = lightLoopOutput.diffuseLighting;\n                      float3 specularLighting = lightLoopOutput.specularLighting;\n\n                      diffuseLighting *= GetCurrentExposureMultiplier();\n                      specularLighting *= GetCurrentExposureMultiplier();\n\n          #ifdef OUTPUT_SPLIT_LIGHTING\n                      if (_EnableSubsurfaceScattering != 0 && ShouldOutputSplitLighting(bsdfData))\n                      {\n                          outColor = float4(specularLighting, 1.0);\n                          outDiffuseLighting = float4(TagLightingForSSS(diffuseLighting), 1.0);\n                      }\n                      else\n                      {\n                          outColor = float4(diffuseLighting + specularLighting, 1.0);\n                          outDiffuseLighting = 0;\n                      }\n                      ENCODE_INTO_SSSBUFFER(surfaceData, posInput.positionSS, outSSSBuffer);\n          #else\n                      outColor = ApplyBlendMode(diffuseLighting, specularLighting, builtinData.opacity);\n                      outColor = EvaluateAtmosphericScattering(posInput, V, outColor);\n          #endif\n\n          ChainFinalColorForward(l, d, outColor);\n\n          #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n                      bool forceNoMotion = any(unity_MotionVectorsParams.yw == 0.0);\n                      // outMotionVec is already initialize at the value of forceNoMotion (see above)\n                      if (!forceNoMotion)\n                      {\n                          float2 motionVec = CalculateMotionVector(v2p.motionVectorCS, v2p.previousPositionCS);\n                          EncodeMotionVector(motionVec * 0.5, outMotionVec);\n                          outMotionVec.zw = 1.0;\n                      }\n          #endif\n                  }\n\n          #ifdef DEBUG_DISPLAY\n              }\n          #endif\n\n          #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n          #endif\n\n          #ifdef UNITY_VIRTUAL_TEXTURING\n             outVTFeedback = builtinData.vtPackedFeedback;\n          #endif\n          }\n\n            ENDHLSL\n        }\n               Pass\n        {\n            // based on HDLitPass.template\n            Name \"GBuffer\"\n            Tags { \"LightMode\" = \"GBuffer\" }\n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n                ZTest [_ZTestGBuffer]\n                Stencil\n                {\n                WriteMask [_StencilWriteMaskGBuffer]\n                Ref [_StencilRefGBuffer]\n                CompFront Always\n                PassFront Replace\n                CompBack Always\n                PassBack Replace\n                }\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n            #pragma target 4.5\n\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n            #pragma multi_compile_fragment _ RENDERING_LAYERS\n            //#pragma multi_compile_raytracing _ LIGHT_LAYERS\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ DEBUG_DISPLAY\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile_fragment PROBE_VOLUMES_OFF PROBE_VOLUMES_L1 PROBE_VOLUMES_L2\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT\n            #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT\n            #pragma multi_compile _ USE_LEGACY_LIGHTMAPS\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n\n\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_GBUFFER\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define _PASSGBUFFER 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n           \n            //-------------------------------------------------------------------------------------\n            // Defines\n            //-------------------------------------------------------------------------------------\n\n\n            \n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n            void Frag(  VertexToPixel v2f,\n                        OUTPUT_GBUFFER(outGBuffer)\n                        #ifdef _DEPTHOFFSET_ON\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                        )\n            {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n                    #if NEED_FACING\n                      , facing\n                    #endif\n                  );\n\n         \n                  ENCODE_INTO_GBUFFER(surfaceData, builtinData, posInput.positionSS, outGBuffer);\n\n                  #ifdef _DEPTHOFFSET_ON\n                        outputDepth = l.outputDepth;\n                  #endif\n            }\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"ShadowCaster\"\n            Tags { \"LightMode\" = \"ShadowCaster\" }\n\n            \n\n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n            ZWrite On\n            ColorMask 0\n            ZClip [_ZClip]\n    \n\n               Cull [_CullMode]\n\n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n            //#pragma multi_compile_local _ _ALPHATEST_ON\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_SHADOWS\n            #define _PASSSHADOW 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            //-------------------------------------------------------------------------------------\n            // Defines\n            //-------------------------------------------------------------------------------------\n            \n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n    \n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n        \n\n            #if defined(WRITE_NORMAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n               #define SV_TARGET_DECAL SV_Target2\n            #elif defined(WRITE_NORMAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n               #define SV_TARGET_DECAL SV_Target1\n            #else\n               #define SV_TARGET_DECAL SV_Target0\n            #endif\n\n\n              void Frag(  VertexToPixel v2f\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                          , out float4 outColor : SV_Target0\n                          #else\n                          #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color as SV_Target0 for alpha to coverage\n                            , out float4 depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target1\n                                #endif\n                            #else\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target0\n                                #endif\n                            #endif\n\n                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                            , out float4 outDecalBuffer : SV_TARGET_DECAL\n                            #endif\n                        #endif\n\n                        #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)\n                        , out float outputDepth : SV_Depth\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n         \n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n                  #ifdef _DEPTHOFFSET_ON\n                     outputDepth = l.outputDepth;\n                  #endif\n\n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2f.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  #endif\n\n                   #if defined(WRITE_NORMAL_BUFFER)\n                      EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                   #endif\n\n                   #if (defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)) || defined(WRITE_RENDERING_LAYER)\n                        DecalPrepassData decalPrepassData;\n                        #ifdef _DISABLE_DECALS\n                            ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);\n                        #else\n                            // We don't have the right to access SurfaceData in a shaderpass.\n                            // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                            // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                            decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                        #endif\n                        decalPrepassData.renderingLayerMask = GetMeshRenderingLayerMask();\n                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                     #endif\n\n\n              }\n\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"DepthOnly\"\n            Tags { \"LightMode\" = \"DepthOnly\" }\n            \n            //-------------------------------------------------------------------------------------\n            // Render Modes (Blend, Cull, ZTest, Stencil, etc)\n            //-------------------------------------------------------------------------------------\n            \n            Cull Back\n        \n            \n            ZWrite On\n        \n            \n            // Stencil setup\n        Stencil\n        {\n           WriteMask [_StencilWriteMaskDepth]\n           Ref [_StencilRefDepth]\n           CompFront Always\n           PassFront Replace\n           CompBack Always\n           PassBack Replace\n        }\n        AlphaToMask [_AlphaCutoffEnable]\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            //#pragma enable_d3d11_debug_symbols\n        \n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n            #pragma multi_compile _ WRITE_MSAA_DEPTH\n            #define _PASSDEPTH 1\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n              #if defined(WRITE_NORMAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n              #define SV_TARGET_DECAL SV_Target2\n              #elif defined(WRITE_NORMAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n              #define SV_TARGET_DECAL SV_Target1\n              #else\n              #define SV_TARGET_DECAL SV_Target0\n              #endif\n\n\n              void Frag(  VertexToPixel v2p\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                            , out float4 outColor : SV_Target0\n                            #else\n                                #ifdef WRITE_MSAA_DEPTH\n                                // We need the depth color as SV_Target0 for alpha to coverage\n                                , out float4 depthColor : SV_Target0\n                                    #ifdef WRITE_NORMAL_BUFFER\n                                    , out float4 outNormalBuffer : SV_Target1\n                                    #endif\n                                #else\n                                    #ifdef WRITE_NORMAL_BUFFER\n                                    , out float4 outNormalBuffer : SV_Target0\n                                    #endif\n                                #endif\n\n                                // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                                #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                                , out float4 outDecalBuffer : SV_TARGET_DECAL\n                                #endif\n                            #endif\n\n                            #if defined(_DEPTHOFFSET_ON) && !defined(SCENEPICKINGPASS)\n                            , out float outputDepth : DEPTH_OFFSET_SEMANTIC\n                            #endif\n                             #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2p);\n                  FragInputs input = BuildFragInputs(v2p);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2p, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n                  // to prevent stripping\n                  surfaceData.normalWS *= saturate(l.Albedo.r + 9999);\n\n                  #ifdef _DEPTHOFFSET_ON\n                     outputDepth = l.outputDepth;\n                  #endif\n\n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = unity_SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                     #endif\n\n                     #if (defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)) || defined(WRITE_RENDERING_LAYER)\n                        DecalPrepassData decalPrepassData;\n                        #ifdef _DISABLE_DECALS\n                            ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);\n                        #else\n                            // We don't have the right to access SurfaceData in a shaderpass.\n                            // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                            // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                            decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                        #endif\n                        decalPrepassData.renderingLayerMask = GetMeshRenderingLayerMask();\n                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                     #endif\n                  #endif\n\n              }\n\n\n\n         ENDHLSL\n    }\n\n\n      \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"META\"\n            Tags { \"LightMode\" = \"META\" }\n            \n            Cull Off\n        \n               Cull [_CullMode]\n\n        \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile_instancing\n\n            //#pragma multi_compile_local _ _ALPHATEST_ON\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n\n \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT\n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #define REQUIRE_DEPTH_TEXTURE\n            #define _PASSMETA 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n\n            \n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n            float4 Frag(VertexToPixel v2f\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n            {\n                FragInputs input = BuildFragInputs(v2f);\n\n                // input.positionSS is SV_Position\n                PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n                SurfaceData surfaceData;\n                BuiltinData builtinData;\n                Surface l;\n                ShaderData d;\n                GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n                // no debug apply during light transport pass\n\n                BSDFData bsdfData = ConvertSurfaceDataToBSDFData(input.positionSS.xy, surfaceData);\n                LightTransportData lightTransportData = GetLightTransportData(surfaceData, builtinData, bsdfData);\n\n                // This shader is call two times. Once for getting emissiveColor, the other time to get diffuseColor\n                // We use unity_MetaFragmentControl to make the distinction.\n                float4 res = float4(0.0, 0.0, 0.0, 1.0);\n\n                if (unity_MetaFragmentControl.x)\n                {\n                    // Apply diffuseColor Boost from LightmapSettings.\n                    // put abs here to silent a warning, no cost, no impact as color is assume to be positive.\n                    res.rgb = clamp(pow(abs(lightTransportData.diffuseColor), saturate(unity_OneOverOutputBoost)), 0, unity_MaxOutputValue);\n                }\n\n                if (unity_MetaFragmentControl.y)\n                {\n                    // emissive use HDR format\n                    res.rgb = lightTransportData.emissiveColor;\n                }\n\n                return res;\n            }\n\n\n\n            ENDHLSL\n        }\n        \n              Pass\n        {\n            // based on HDLitPass.template\n            Name \"SceneSelectionPass\"\n            Tags { \"LightMode\" = \"SceneSelectionPass\" }\n        \n            Cull Off\n            ColorMask 0\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n            #pragma instancing_options renderinglayer\n        \n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n            //-------------------------------------------------------------------------------------\n            // Variant Definitions (active field translations to HDRP defines)\n            //-------------------------------------------------------------------------------------\n            // #define _MATERIAL_FEATURE_SUBSURFACE_SCATTERING 1\n            // #define _MATERIAL_FEATURE_TRANSMISSION 1\n            // #define _MATERIAL_FEATURE_ANISOTROPY 1\n            // #define _MATERIAL_FEATURE_IRIDESCENCE 1\n            // #define _MATERIAL_FEATURE_SPECULAR_COLOR 1\n            #define _ENABLE_FOG_ON_TRANSPARENT 1\n            // #define _AMBIENT_OCCLUSION 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO 1\n            // #define _SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL 1\n            // #define _SPECULAR_OCCLUSION_CUSTOM 1\n            // #define _ENERGY_CONSERVING_SPECULAR 1\n            // #define _ENABLE_GEOMETRIC_SPECULAR_AA 1\n            // #define _HAS_REFRACTION 1\n            // #define _REFRACTION_PLANE 1\n            // #define _REFRACTION_SPHERE 1\n            // #define _DISABLE_DECALS 1\n            // #define _DISABLE_SSR 1\n            // #define _ADD_PRECOMPUTED_VELOCITY\n            // #define _WRITE_TRANSPARENT_MOTION_VECTOR 1\n            // #define _DEPTHOFFSET_ON 1\n            // #define _BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define SCENESELECTIONPASS\n            #define _PASSSCENESELECT 1\n\n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n        \n            \n\n        \n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n  \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n        \n\n            \n            void Frag(  VertexToPixel IN\n            #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_Target0\n                #ifdef WRITE_MSAA_DEPTH\n                , out float1 depthColor : SV_Target1\n                #endif\n            #elif defined(WRITE_MSAA_DEPTH) // When only WRITE_MSAA_DEPTH is define and not WRITE_NORMAL_BUFFER it mean we are Unlit and only need depth, but we still have normal buffer binded\n            , out float4 outNormalBuffer : SV_Target0\n            , out float1 depthColor : SV_Target1\n            #elif defined(SCENESELECTIONPASS)\n            , out float4 outColor : SV_Target0\n            #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n        )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n             FragInputs input = BuildFragInputs(IN);\n\n             // input.positionSS is SV_Position\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n\n             float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n            SurfaceData surfaceData;\n            BuiltinData builtinData;\n            Surface l;\n            ShaderData d;\n            GetSurfaceAndBuiltinData(IN, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = l.outputDepth;\n         #endif\n\n         #ifdef WRITE_NORMAL_BUFFER\n             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), posInput.positionSS, outNormalBuffer);\n             #ifdef WRITE_MSAA_DEPTH\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n             #endif\n         #elif defined(WRITE_MSAA_DEPTH) // When we are MSAA depth only without normal buffer\n             // Due to the binding order of these two render targets, we need to have them both declared\n             outNormalBuffer = float4(0.0, 0.0, 0.0, 1.0);\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n         #elif defined(SCENESELECTIONPASS)\n             // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n             outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n         #endif\n         }\n\n         ENDHLSL\n     }\n\n        \n              Pass\n        {\n            Name \"ScenePickingPass\"\n            Tags\n            {\n               \"LightMode\" = \"Picking\"\n            }\n            \n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma editor_sync_compilation\n            #pragma instancing_options renderinglayer\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n\n            #define SHADERPASS SHADERPASS_DEPTH_ONLY\n            #define SCENEPICKINGPASS\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n            void Frag( VertexToPixel v2f\n                          #if defined(SCENESELECTIONPASS) || defined(SCENEPICKINGPASS)\n                          , out float4 outColor : SV_Target0\n                          #else\n                          #ifdef WRITE_MSAA_DEPTH\n                            // We need the depth color as SV_Target0 for alpha to coverage\n                            , out float4 depthColor : SV_Target0\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target1\n                                #endif\n                            #else\n                                #ifdef WRITE_NORMAL_BUFFER\n                                , out float4 outNormalBuffer : SV_Target0\n                                #endif\n                            #endif\n\n                            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n                            #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                            , out float4 outDecalBuffer : SV_TARGET_DECAL\n                            #endif\n                        #endif\n                        #if NEED_FACING\n                           , bool facing : SV_IsFrontFace\n                        #endif\n\n                      )\n              {\n                  UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n                  FragInputs input = BuildFragInputs(v2f);\n\n                  // input.positionSS is SV_Position\n                  PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n                  float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n                  SurfaceData surfaceData;\n                  BuiltinData builtinData;\n                  Surface l;\n                  ShaderData d;\n                  GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n\n                  \n                  #ifdef SCENESELECTIONPASS\n                      // We use depth prepass for scene selection in the editor, this code allow to output the outline correctly\n                      outColor = float4(_ObjectId, _PassValue, 1.0, 1.0);\n                  #elif defined(SCENEPICKINGPASS)\n                      outColor = _SelectionID;\n                  #else\n                     #ifdef WRITE_MSAA_DEPTH\n                       // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n                       depthColor = v2p.pos.z;\n\n                       #ifdef _ALPHATOMASK_ON\n                          // Alpha channel is used for alpha to coverage\n                          depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n                       #endif // alphatomask\n                     #endif // msaa_depth\n                  \n\n                     #if defined(WRITE_NORMAL_BUFFER)\n                        EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n                     #endif\n\n                     #if (defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)) || defined(WRITE_RENDERING_LAYER)\n                        DecalPrepassData decalPrepassData;\n                        #ifdef _DISABLE_DECALS\n                            ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);\n                        #else\n                            // We don't have the right to access SurfaceData in a shaderpass.\n                            // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n                            // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n                            decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n                        #endif\n                        decalPrepassData.renderingLayerMask = GetMeshRenderingLayerMask();\n                        EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n                     #endif\n                  #endif\n\n\n              }\n\n         ENDHLSL\n        }\n\n              Pass\n        {\n            Name \"MotionVectors\"\n            Tags\n            {\n               \"LightMode\" = \"MotionVectors\"\n            }\n    \n            // Render State\n            Cull Back\n            ZWrite On\n            Stencil\n               {\n                  WriteMask [_StencilWriteMaskMV]\n                  Ref [_StencilRefMV]\n                  CompFront Always\n                  PassFront Replace\n                  CompBack Always\n                  PassBack Replace\n               }\n\n               Cull [_CullMode]\n\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n            #pragma multi_compile_instancing\n            #pragma multi_compile _ DOTS_INSTANCING_ON\n            #pragma instancing_options renderinglayer\n            #pragma multi_compile _ LOD_FADE_CROSSFADE\n\n            #pragma multi_compile _ WRITE_MSAA_DEPTH\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            #pragma multi_compile _ WRITE_NORMAL_BUFFER\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            #pragma multi_compile _ WRITE_DECAL_BUFFER\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                \n        \n\n            #define SHADERPASS SHADERPASS_MOTION_VECTORS\n            #define RAYTRACING_SHADER_GRAPH_DEFAULT\n            #define VARYINGS_NEED_PASS\n            #define _PASSMOTIONVECTOR 1\n\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/LitDecalData.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n#if defined(WRITE_DECAL_BUFFER) && defined(WRITE_MSAA_DEPTH)\n#define SV_TARGET_NORMAL SV_Target3\n#elif defined(WRITE_DECAL_BUFFER) || defined(WRITE_MSAA_DEPTH)\n#define SV_TARGET_NORMAL SV_Target2\n#else\n#define SV_TARGET_NORMAL SV_Target1\n#endif\n\n// Caution: Motion vector pass is different from Depth prepass, it render normal buffer last instead of decal buffer last\n// and thus, we force a write of 0 if _DISABLE_DECALS so we always write in the decal buffer.\n// This is required as we can't make distinction  between deferred (write normal buffer) and forward (write normal buffer)\n// in the context of the motion vector pass. The cost is acceptable as it is only do object with motion vector (usualy skin object)\n// that most of the time use Forward Material (so are already writing motion vector data).\n// So note that here unlike for depth prepass we don't check && !defined(_DISABLE_DECALS)\nvoid Frag(  VertexToPixel v2f\n            #ifdef WRITE_MSAA_DEPTH\n            // We need the depth color as SV_Target0 for alpha to coverage\n            , out float4 depthColor : SV_Target0\n            , out float4 outMotionVector : SV_Target1\n                #ifdef WRITE_DECAL_BUFFER\n                , out float4 outDecalBuffer : SV_Target2\n                #endif\n            #else\n            // When no MSAA, the motion vector is always the first buffer\n            , out float4 outMotionVector : SV_Target0\n                #ifdef WRITE_DECAL_BUFFER\n                , out float4 outDecalBuffer : SV_Target1\n                #endif\n            #endif\n\n            // Decal buffer must be last as it is bind but we can optionally write into it (based on _DISABLE_DECALS)\n            #ifdef WRITE_NORMAL_BUFFER\n            , out float4 outNormalBuffer : SV_TARGET_NORMAL\n            #endif\n\n            #ifdef _DEPTHOFFSET_ON\n            , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n        )\n          {\n\n              FragInputs input = BuildFragInputs(v2f);\n              PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS);\n\n              float3 V = GetWorldSpaceNormalizeViewDir(input.positionRWS);\n\n\n              SurfaceData surfaceData;\n              BuiltinData builtinData;\n              Surface l;\n              ShaderData d;\n              GetSurfaceAndBuiltinData(v2f, input, V, posInput, surfaceData, builtinData, l, d\n               #if NEED_FACING\n                  , facing\n               #endif\n               );\n\n            #ifdef _DEPTHOFFSET_ON\n                v2f.motionVectorCS.w += builtinData.depthOffset;\n                v2f.previousPositionCS.w += builtinData.depthOffset;\n            #endif\n\n             // TODO: How to allow overriden motion vector from GetSurfaceAndBuiltinData ?\n             float2 motionVector = CalculateMotionVector(v2f.motionVectorCS, v2f.previousPositionCS);\n\n             // Convert from Clip space (-1..1) to NDC 0..1 space.\n             // Note it doesn't mean we don't have negative value, we store negative or positive offset in NDC space.\n             // Note: ((positionCS * 0.5 + 0.5) - (v2f.previousPositionCS * 0.5 + 0.5)) = (motionVector * 0.5)\n             EncodeMotionVector(motionVector * 0.5, outMotionVector);\n\n             // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n             bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n             // Setting the motionVector to a value more than 2 set as a flag for \"force no motion\". This is valid because, given that the velocities are in NDC,\n             // a value of >1 can never happen naturally, unless explicitely set. \n             if (forceNoMotion)\n                 outMotionVector = float4(2.0, 0.0, 0.0, 0.0);\n\n         // Depth and Alpha to coverage\n         #ifdef WRITE_MSAA_DEPTH\n             // In case we are rendering in MSAA, reading the an MSAA depth buffer is way too expensive. To avoid that, we export the depth to a color buffer\n             depthColor = v2f.pos.z;\n\n             #ifdef _ALPHATOMASK_ON\n             // Alpha channel is used for alpha to coverage\n             depthColor.a = SharpenAlpha(builtinData.opacity, builtinData.alphaClipTreshold);\n             #endif\n         #endif\n\n         // Normal Buffer Processing\n         #ifdef WRITE_NORMAL_BUFFER\n             EncodeIntoNormalBuffer(ConvertSurfaceDataToNormalData(surfaceData), outNormalBuffer);\n         #endif\n\n         #if defined(WRITE_DECAL_BUFFER)\n             DecalPrepassData decalPrepassData;\n             // Force a write in decal buffer even if decal is disab. This is a neutral value which have no impact for later pass\n             #ifdef _DISABLE_DECALS\n             ZERO_INITIALIZE(DecalPrepassData, decalPrepassData);\n             #else\n             // We don't have the right to access SurfaceData in a shaderpass.\n             // However it would be painful to have to add a function like ConvertSurfaceDataToDecalPrepassData() to every Material to return geomNormalWS anyway\n             // Here we will put the constrain that any Material requiring to support Decal, will need to have geomNormalWS as member of surfaceData (and we already require normalWS anyway)\n             decalPrepassData.geomNormalWS = surfaceData.geomNormalWS;\n             decalPrepassData.renderingLayerMask = GetMeshRenderingLayerMask();\n             #endif\n             EncodeIntoDecalPrepassBuffer(decalPrepassData, outDecalBuffer);\n             outDecalBuffer.w = (GetMeshRenderingLayerMask() & 0x000000FF) / 255.0;\n         #endif\n\n         #ifdef _DEPTHOFFSET_ON\n             outputDepth = posInput.deviceDepth;\n         #endif\n          }\n\n            ENDHLSL\n        }\n\n      \n              Pass\n        {\n            Name \"FullScreenDebug\"\n            Tags\n            {\n               \"LightMode\" = \"FullScreenDebug\"\n            }\n    \n            // Render State\n            Cull Back\n            ZTest LEqual\n            ZWrite Off\n            \n            //-------------------------------------------------------------------------------------\n            // End Render Modes\n            //-------------------------------------------------------------------------------------\n        \n            HLSLPROGRAM\n        \n            #pragma target 4.5\n            #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch\n\n\n\n            //#pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT\n            //#pragma shader_feature_local _BLENDMODE_OFF _BLENDMODE_ALPHA _BLENDMODE_ADD _BLENDMODE_PRE_MULTIPLY\n            //#pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY\n            //#pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC\n            //#pragma shader_feature_local _ _ENABLE_FOG_ON_TRANSPARENT\n            //#pragma shader_feature_local _ _DISABLE_DECALS\n            //#pragma shader_feature_local _ _DISABLE_SSR\n            //#pragma shader_feature_local _ _DISABLE_SSR_TRANSPARENT\n            //#pragma shader_feature_local _REFRACTION_OFF _REFRACTION_PLANE _REFRACTION_SPHERE _REFRACTION_THIN\n                #pragma multi_compile _ LOD_FADE_CROSSFADE\n        \n\n            #define SHADERPASS SHADERPASS_FULL_SCREEN_DEBUG\n            #define _PASSFULLSCREENDEBUG 1\n            \n            \n\n\n   #define _HDRP 1\n#define NEED_FACING 1\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n                  // useful conversion functions to make surface shader code just work\n\n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(tex) TEXTURE2D_ARRAY(tex);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n\n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n\n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #ifndef SHADER_STAGE_FRAGMENT\n        #if !defined(SHADOW_ULTRA_LOW) && !defined(SHADOW_LOW) && !defined(SHADOW_MEDIUM) && !defined(SHADOW_HIGH) // ultra low come from volumetricLighting.compute\n            #define SHADOW_MEDIUM\n        #endif\n        #if !defined(AREA_SHADOW_LOW) && !defined(AREA_SHADOW_MEDIUM) && !defined(AREA_SHADOW_HIGH) // low come from volumetricLighting.compute\n            #define AREA_SHADOW_MEDIUM\n        #endif\n      #endif\n                 \n\n\n// HDRP Adapter stuff\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl\"\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl\" // Required by Tessellation.hlsl\n            \t#include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl\"\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\" // Required to be include before we include properties as it define DECLARE_STACK_CB\n                #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS\n                // Always include Shader Graph version\n                // Always include last to avoid double macros\n                #include \"Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl\" // Need to be here for Gradient struct definition\n\n\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl\"\n            \n            \n\n            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT \n            #define RAYTRACING_SHADER_GRAPH_HIGH\n            #endif\n    \n            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED\n            #define RAYTRACING_SHADER_GRAPH_LOW\n            #endif\n            // end\n    \n\n\n\n            // If we use subsurface scattering, enable output split lighting (for forward pass)\n            #if defined(_MATERIAL_FEATURE_SUBSURFACE_SCATTERING) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define OUTPUT_SPLIT_LIGHTING\n            #endif\n\n            #define HAVE_RECURSIVE_RENDERING\n\n            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS\n               #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)\n                  #define WRITE_NORMAL_BUFFER\n               #endif\n            #endif\n\n            #ifndef DEBUG_DISPLAY\n               // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)\n               // Don't do it with debug display mode as it is possible there is no depth prepass in this case\n               #if !defined(_SURFACE_TYPE_TRANSPARENT) && defined(_ALPHATEST)\n                  #if SHADERPASS == SHADERPASS_FORWARD\n                  #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST\n                  #elif SHADERPASS == SHADERPASS_GBUFFER\n                  #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST\n                  #endif\n               #endif\n            #endif\n\n            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass\n            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _DEFERRED_CAPABLE_MATERIAL\n            #endif\n    \n            // Translate transparent motion vector define\n            #if defined(_TRANSPARENT_WRITES_MOTION_VEC) && defined(_SURFACE_TYPE_TRANSPARENT)\n               #define _WRITE_TRANSPARENT_MOTION_VECTOR\n            #endif\n\n\n\n\n            CBUFFER_START(UnityPerMaterial)\n               float _UseShadowThreshold;\n               float _BlendMode;\n               float _EnableBlendModePreserveSpecularLighting;\n               float _RayTracing;\n               float _RefractionModel;\n\n              \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n    \n\n\n             // -- Property used by ScenePickingPass\n               #ifdef SCENEPICKINGPASS\n               float4 _SelectionID;\n               #endif\n    \n               // -- Properties used by SceneSelectionPass\n               #ifdef SCENESELECTIONPASS\n               int _ObjectId;\n               int _PassValue;\n               #endif\n  \n           \n            // data across stages, stripped like the above.\n            struct VertexToPixel\n            {\n               float4 pos : SV_POSITION;\n               float3 worldPos : TEXCOORD0;\n               float3 worldNormal : TEXCOORD1;\n               float4 worldTangent : TEXCOORD2;\n               float4 texcoord0 : TEXCOORD3;\n               float4 texcoord1 : TEXCOORD4;\n               float4 texcoord2 : TEXCOORD5;\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD6;\n               // #endif\n\n               // #if %SCREENPOSREQUIREKEY%\n               // float4 screenPos : TEXCOORD7;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD12;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD13;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD14;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD15;\n               // #endif\n\n               #if UNITY_ANY_INSTANCING_ENABLED\n                  UNITY_VERTEX_INPUT_INSTANCE_ID\n               #endif // UNITY_ANY_INSTANCING_ENABLED\n\n               #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n                  float4 previousPositionCS : TEXCOORD16; // Contain previous transform position (in case of skinning for example)\n                  float4 motionVectorCS : TEXCOORD17;\n               #endif\n\n               UNITY_VERTEX_OUTPUT_STEREO\n            }; \n\n\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Lit/Lit.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n    \n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n\n#if (SHADERPASS == SHADERPASS_LIGHT_TRANSPORT)\n\n   // This was not in constant buffer in original unity, so keep outiside. But should be in as ShaderRenderPass frequency\n   float unity_OneOverOutputBoost;\n   float unity_MaxOutputValue;\n\n   CBUFFER_START(UnityMetaPass)\n   // x = use uv1 as raster position\n   // y = use uv2 as raster position\n   bool4 unity_MetaVertexControl;\n\n   // x = return albedo\n   // y = return normal\n   bool4 unity_MetaFragmentControl;\n   CBUFFER_END\n\n   VertexToPixel Vert(VertexData inputMesh)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n       UNITY_SETUP_INSTANCE_ID(inputMesh);\n       UNITY_TRANSFER_INSTANCE_ID(inputMesh, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       // Output UV coordinate in vertex shader\n       float2 uv = float2(0.0, 0.0);\n\n       if (unity_MetaVertexControl.x)\n       {\n           uv = inputMesh.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;\n       }\n       else if (unity_MetaVertexControl.y)\n       {\n           uv = inputMesh.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n       }\n\n       // OpenGL right now needs to actually use the incoming vertex position\n       // so we create a fake dependency on it here that haven't any impact.\n       output.pos = float4(uv * 2.0 - 1.0, inputMesh.vertex.z > 0 ? 1.0e-4 : 0.0, 1.0);\n\n       output.worldPos = TransformObjectToWorld(inputMesh.vertex.xyz).xyz;\n\n       // Normal is required for triplanar mapping\n       output.worldNormal = TransformObjectToWorldNormal(inputMesh.normal);\n       // Not required but assign to silent compiler warning\n       output.worldTangent = float4(1.0, 0.0, 0.0, 0.0);\n\n       output.texcoord0 = inputMesh.texcoord0;\n       output.texcoord1 = inputMesh.texcoord1;\n       output.texcoord2 = inputMesh.texcoord2;\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = inputMesh.texcoord3;\n       // #endif\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = inputMesh.vertexColor;\n       // #endif\n\n       return output;\n   }\n#else\n\n   #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n      #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariablesMatrixDefsHDCamera.hlsl\"\n\n      void MotionVectorPositionZBias(VertexToPixel input)\n      {\n      #if UNITY_REVERSED_Z\n          input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n      #else\n          input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n      #endif\n      }\n\n   #endif\n\n   VertexToPixel Vert(VertexData input)\n   {\n       VertexToPixel output;\n       ZERO_INITIALIZE(VertexToPixel, output);\n\n       UNITY_SETUP_INSTANCE_ID(input);\n       UNITY_TRANSFER_INSTANCE_ID(input, output);\n       UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);\n\n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n         VertexData previousMesh = input;\n       #endif\n\n       ChainModifyVertex(input, output, _Time);\n\n       // This return the camera relative position (if enable)\n       float3 positionRWS = TransformObjectToWorld(input.vertex.xyz);\n       float3 normalWS = TransformObjectToWorldNormal(input.normal);\n       float4 tangentWS = float4(TransformObjectToWorldDir(input.tangent.xyz), input.tangent.w);\n\n\n       output.worldPos = GetAbsolutePositionWS(positionRWS);\n       output.pos = TransformWorldToHClip(positionRWS);\n       output.worldNormal = normalWS;\n       output.worldTangent = tangentWS;\n\n\n       output.texcoord0 = input.texcoord0;\n       output.texcoord1 = input.texcoord1;\n       output.texcoord2 = input.texcoord2;\n\n       // #if %TEXCOORD3REQUIREKEY%\n       // output.texcoord3 = input.texcoord3;\n       // #endif\n\n       // #if %VERTEXCOLORREQUIREKEY%\n       // output.vertexColor = input.vertexColor;\n       // #endif\n\n       // #if %SCREENPOSREQUIREKEY%\n       // output.screenPos = ComputeScreenPos(output.pos, _ProjectionParams.x);\n       // #endif\n   \n       #if _HDRP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n          #if !defined(TESSELLATION_ON)\n            MotionVectorPositionZBias(output);\n          #endif\n\n          output.motionVectorCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionRWS.xyz, 1.0));\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n          {\n              output.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n          }\n          else\n          {\n            bool hasDeformation = unity_MotionVectorsParams.x > 0.0; // Skin or morph target\n\n            float3 effectivePositionOS = (hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz);\n            #if defined(_ADD_PRECOMPUTED_VELOCITY)\n               effectivePositionOS -= input.precomputedVelocity;\n            #endif\n\n            previousMesh.vertex = float4(effectivePositionOS, 1);\n            VertexToPixel dummy = (VertexToPixel)0;\n            \n\n            ChainModifyVertex(previousMesh, dummy, _LastTimeParameters);\n\n            // we might need this for skinned objects?\n            //float3 normalWS = TransformPreviousObjectToWorldNormal(input.normal).xyz;\n            float3 previousPositionRWS = TransformPreviousObjectToWorld(previousMesh.vertex.xyz);\n\n            #ifdef _WRITE_TRANSPARENT_MOTION_VECTOR\n            if (_TransparentCameraOnlyMotionVectors > 0)\n            {\n               previousPositionRWS = positionRWS.xyz;\n            }\n            #endif // _WRITE_TRANSPARENT_MOTION_VECTOR\n\n            output.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionRWS, 1.0));\n         }\n       #endif // _HDRP && _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n\n\n       return output;\n   }\n\n\n#endif\n\n\n\n            \n\n            \n\n               #if defined(WRITE_DECAL_BUFFER) && !defined(_DISABLE_DECALS)\n                  #include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalPrepassBuffer.hlsl\"\n               #endif\n\n                FragInputs BuildFragInputs(VertexToPixel input)\n                {\n                    UNITY_SETUP_INSTANCE_ID(input);\n                    FragInputs output;\n                    ZERO_INITIALIZE(FragInputs, output);\n            \n                    // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).\n                    // TODO: this is a really poor workaround, but the variable is used in a bunch of places\n                    // to compute normals which are then passed on elsewhere to compute other values...\n                    output.tangentToWorld = k_identity3x3;\n                    output.positionSS = input.pos;       // input.positionCS is SV_Position\n                    // BETTER SHADERS: because we transform world position into actual world space for things like\n                    // triplanar, etc, we have to back transform it here for lighting\n                    output.positionRWS = GetCameraRelativePositionWS(input.worldPos);\n                    output.tangentToWorld = BuildTangentToWorld(input.worldTangent, input.worldNormal);\n                    output.texCoord0 = input.texcoord0;\n                    output.texCoord1 = input.texcoord1;\n                    output.texCoord2 = input.texcoord2;\n            \n                    return output;\n                }\n\n#if UNITY_VERSION > UNITY_2022_3_12\n                void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, Surface surfaceDescription, float3 normalTS,\n                    inout SurfaceData surfaceData)\n                {\n                    float3 doubleSidedConstants = GetDoubleSidedConstants();\n                    \n                #ifdef DECAL_NORMAL_BLENDING\n                    // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert\n                    // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space\n                    normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(normalTS,\n                    fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);\n                \n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                \n                    GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);\n                #else\n                    // normal delivered to master node\n                \n                    #if HAVE_DECALS\n                    if (_EnableDecals)\n                    {\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                \n                        // Both uses and modifies 'surfaceData.normalWS'.\n                        DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                        ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);\n                        ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);\n                    }\n                    #endif\n                #endif\n                }\n#endif\n\n               void BuildSurfaceData(FragInputs fragInputs, inout Surface surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)\n               {\n                   // setup defaults -- these are used if the graph doesn't output a value\n                   ZERO_INITIALIZE(SurfaceData, surfaceData);\n        \n                   // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct\n                   // however specularOcclusion can come from the graph, so need to be init here so it can be override.\n                   surfaceData.specularOcclusion = 1.0;\n\n                   // copy across graph values, if defined\n                   surfaceData.baseColor =                 surfaceDescription.Albedo;\n                   surfaceData.perceptualSmoothness =      surfaceDescription.Smoothness;\n                   surfaceData.ambientOcclusion =          surfaceDescription.Occlusion;\n                   surfaceData.specularOcclusion =         surfaceDescription.SpecularOcclusion;\n                   surfaceData.metallic =                  surfaceDescription.Metallic;\n                   surfaceData.subsurfaceMask =            surfaceDescription.SubsurfaceMask;\n                   surfaceData.thickness =                 surfaceDescription.Thickness;\n                   surfaceData.diffusionProfileHash =      asuint(surfaceDescription.DiffusionProfileHash);\n                   #if _USESPECULAR\n                      surfaceData.specularColor =             surfaceDescription.Specular;\n                   #endif\n                   surfaceData.coatMask =                  surfaceDescription.CoatMask;\n                   surfaceData.anisotropy =                surfaceDescription.Anisotropy;\n                   surfaceData.iridescenceMask =           surfaceDescription.IridescenceMask;\n                   surfaceData.iridescenceThickness =      surfaceDescription.IridescenceThickness;\n\n\n\n                   #if defined(_REFRACTION_PLANE) || defined(_REFRACTION_SPHERE) || defined(_REFRACTION_THIN)\n                        if (_EnableSSRefraction)\n                        {\n                            surfaceData.transmittanceMask = (1.0 - surfaceDescription.Alpha);\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                        else\n                        {\n                            surfaceData.ior = surfaceDescription.ior;\n                            surfaceData.transmittanceColor = surfaceDescription.transmittanceColor;\n                            surfaceData.atDistance = surfaceDescription.atDistance;\n                            surfaceData.transmittanceMask = surfaceDescription.transmittanceMask;\n                            surfaceDescription.Alpha = 1.0;\n                        }\n                    #else\n                        surfaceData.ior = 1.0;\n                        surfaceData.transmittanceColor = float3(1.0, 1.0, 1.0);\n                        surfaceData.atDistance = 1.0;\n                        surfaceData.transmittanceMask = 0.0;\n                    #endif\n\n                    \n\n                    // These static material feature allow compile time optimization\n                    surfaceData.materialFeatures = MATERIALFEATUREFLAGS_LIT_STANDARD;\n                    #ifdef _MATERIAL_FEATURE_SUBSURFACE_SCATTERING\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SUBSURFACE_SCATTERING;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_TRANSMISSION\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_TRANSMISSION;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_ANISOTROPY\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_ANISOTROPY;\n                        surfaceData.normalWS = float3(0, 1, 0);\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_IRIDESCENCE\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_IRIDESCENCE;\n                    #endif\n                \n                    #ifdef _MATERIAL_FEATURE_SPECULAR_COLOR\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_SPECULAR_COLOR;\n                    #endif\n                \n                    #if defined(_MATERIAL_FEATURE_CLEAR_COAT) || _CLEARCOAT\n                        surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_LIT_CLEAR_COAT;\n                    #endif\n                \n                    #if defined (_MATERIAL_FEATURE_SPECULAR_COLOR) && defined (_ENERGY_CONSERVING_SPECULAR)\n                        // Require to have setup baseColor\n                        // Reproduce the energy conservation done in legacy Unity. Not ideal but better for compatibility and users can unchek it\n                        surfaceData.baseColor *= (1.0 - Max3(surfaceData.specularColor.r, surfaceData.specularColor.g, surfaceData.specularColor.b));\n                    #endif\n\n                float3 normalTS = surfaceDescription.Normal;\n                #if !_WORLDSPACENORMAL\n                    surfaceData.normalWS = mul(surfaceDescription.Normal, fragInputs.tangentToWorld);\n                #else\n                    normalTS = mul(fragInputs.tangentToWorld, surfaceDescription.Normal);\n                    surfaceData.normalWS = surfaceDescription.Normal;\n                #endif\n\n\n                #if UNITY_VERSION > UNITY_2022_3_12\n                    ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, normalTS, surfaceData);\n                #else\n                    #ifdef DECAL_NORMAL_BLENDING\n                        #if HAVE_DECALS\n                        float alpha = 1.0;\n                        alpha = surfaceDescription.Alpha;\n                        if (_EnableDecals)\n                        {\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData, normalTS);\n                        }\n                        #endif\n                    #else\n                        #if HAVE_DECALS\n                        if (_EnableDecals)\n                        {\n                            float alpha = 1.0;\n                            alpha = surfaceDescription.Alpha;\n                            // Both uses and modifies 'surfaceData.normalWS'.\n                            DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);\n                            ApplyDecalToSurfaceData(decalSurfaceData, fragInputs.tangentToWorld[2], surfaceData);\n                        }\n                        #endif\n                    #endif\n                 #endif\n\n                \n\n                   surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];\n        \n                   surfaceData.tangentWS = normalize(fragInputs.tangentToWorld[0].xyz);    // The tangent is not normalize in tangentToWorld for mikkt. TODO: Check if it expected that we normalize with Morten. Tag: SURFACE_GRADIENT\n\n\n                    bentNormalWS = surfaceData.normalWS;\n                \n                    surfaceData.tangentWS = Orthonormalize(surfaceData.tangentWS, surfaceData.normalWS);\n                \n                    #ifdef DEBUG_DISPLAY\n                        if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)\n                        {\n                            // TODO: need to update mip info\n                            surfaceData.metallic = 0;\n                        }\n                \n                        // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData\n                        // as it can modify attribute use for static lighting\n                        ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);\n                    #endif\n                \n                    // By default we use the ambient occlusion with Tri-ace trick (apply outside) for specular occlusion.\n                    // If user provide bent normal then we process a better term\n                    #if defined(_SPECULAR_OCCLUSION_CUSTOM)\n                        // Just use the value passed through via the slot (not active otherwise)\n                    #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)\n                        // If we have bent normal and ambient occlusion, process a specular occlusion\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, surfaceData.normalWS, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));\n                    #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)\n                        surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(surfaceData.normalWS, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));\n                    #endif\n                \n                    #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)\n                        surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);\n                    #endif\n               }\n        \n               void GetSurfaceAndBuiltinData(VertexToPixel m2ps, FragInputs fragInputs, float3 V, inout PositionInputs posInput,\n                     out SurfaceData surfaceData, out BuiltinData builtinData, inout Surface l, inout ShaderData d\n                     #if NEED_FACING\n                        , bool facing\n                     #endif\n                  )\n               {\n                 // Removed since crossfade does not work, probably needs extra material setup.   \n                 //#if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)\n                 //   #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group\n                 //      LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);\n                 //   #endif\n                 //#endif\n\n\n\n\n                 d = CreateShaderData(m2ps\n                    #if NEED_FACING\n                       , facing\n                    #endif\n                 );\n\n                 l = (Surface)0;\n\n                 l.Albedo = half3(0.5, 0.5, 0.5);\n                 l.Normal = float3(0,0,1);\n                 l.Occlusion = 1;\n                 l.Alpha = 1;\n                 l.SpecularOcclusion = 1;\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    l.outputDepth = d.clipPos.z;\n                 #endif\n\n                 ChainSurfaceFunction(l, d);\n\n                 #if !defined(SHADER_STAGE_RAY_TRACING) && defined(_DEPTHOFFSET_ON)\n                    posInput.deviceDepth = l.outputDepth;\n                 #endif\n\n                 #if _UNLIT\n                     //l.Emission = l.Albedo;\n                     //l.Albedo = 0;\n                     l.Normal = half3(0,0,1);\n                     l.Occlusion = 1;\n                     l.Metallic = 0;\n                     l.Specular = 0;\n                 #endif\n\n                 surfaceData.geomNormalWS = d.worldSpaceNormal;\n                 surfaceData.tangentWS = d.worldSpaceTangent;\n                 fragInputs.tangentToWorld = d.TBNMatrix;\n\n                 float3 bentNormalWS;\n\n                 BuildSurfaceData(fragInputs, l, V, posInput, surfaceData, bentNormalWS);\n\n\n                  float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //#ifdef FRAG_INPUTS_USE_TEXCOORD1\n                  //      float4 lightmapTexCoord1 = fragInputs.texCoord1;\n                  //  #else\n                  //      float4 lightmapTexCoord1 = float4(0,0,0,0);\n                  //  #endif\n            \n                  //  #ifdef FRAG_INPUTS_USE_TEXCOORD2\n                  //      float4 lightmapTexCoord2 = fragInputs.texCoord2;\n                  //  #else\n                  //      float4 lightmapTexCoord2 = float4(0,0,0,0);\n                  //  #endif\n\n\n                 InitBuiltinData(posInput, l.Alpha, bentNormalWS, -d.worldSpaceNormal, lightmapTexCoord1, lightmapTexCoord2, builtinData);\n\n                 \n\n                 builtinData.emissiveColor = l.Emission;\n\n                 #if defined(_OVERRIDE_BAKEDGI)\n                    builtinData.bakeDiffuseLighting = l.DiffuseGI;\n                    builtinData.backBakeDiffuseLighting = l.BackDiffuseGI;\n                    builtinData.emissiveColor += l.SpecularGI;\n                 #endif\n\n                 #if defined(_OVERRIDE_SHADOWMASK)\n                    builtinData.shadowMask0 = l.ShadowMask.x;\n                    builtinData.shadowMask1 = l.ShadowMask.y;\n                    builtinData.shadowMask2 = l.ShadowMask.z;\n                    builtinData.shadowMask3 = l.ShadowMask.w;\n                 #endif\n\n                  #ifdef UNITY_VIRTUAL_TEXTURING\n                     //builtinData.vtPackedFeedback = surfaceData.VTPackedFeedback;\n                  #endif\n\n                  #if (SHADERPASS == SHADERPASS_DISTORTION)\n                     builtinData.distortion = surfaceData.Distortion;\n                     builtinData.distortionBlur = surfaceData.DistortionBlur;\n                  #endif\n\n                  #ifndef SHADER_UNLIT\n                    // PostInitBuiltinData call ApplyDebugToBuiltinData\n                    PostInitBuiltinData(V, posInput, surfaceData, builtinData);\n                  #else\n                    ApplyDebugToBuiltinData(builtinData);\n                  #endif\n         \n                  RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS\n               }\n\n\n\n#define DEBUG_DISPLAY\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl\"\n#include \"Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/FullScreenDebug.hlsl\"\n\n         #if !defined(_DEPTHOFFSET_ON)\n         [earlydepthstencil] // quad overshading debug mode writes to UAV\n         #endif\n         void Frag(VertexToPixel v2f\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         )\n         {\n             UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v2f);\n             FragInputs input = BuildFragInputs(v2f);\n\n             PositionInputs posInput = GetPositionInput(input.positionSS.xy, _ScreenSize.zw, input.positionSS.z, input.positionSS.w, input.positionRWS.xyz);\n\n         #ifdef PLATFORM_SUPPORTS_PRIMITIVE_ID_IN_PIXEL_SHADER\n             if (_DebugFullScreenMode == FULLSCREENDEBUGMODE_QUAD_OVERDRAW)\n             {\n                 IncrementQuadOverdrawCounter(posInput.positionSS.xy, input.primitiveID);\n             }\n         #endif\n         }\n\n            ENDHLSL\n        }\n\n      \n\n\n      \n   }\n\n   \n   \n   \n}\n"},{"srpTarget":1,"UnityVersionMin":20233,"UnityVersionMax":30000,"shader":{"instanceID":0},"shaderSrc":"////////////////////////////////////////\n// Generated with Better Shaders\n//\n// Auto-generated shader code, don't hand edit!\n//\n//   Unity Version: 2021.3.38f1\n//   Render Pipeline: URP2023\n//   Platform: WindowsEditor\n////////////////////////////////////////\n\n\nShader \"UMA/Diffuse_Normal_Metallic\"\n{\n   Properties\n   {\n      [HideInInspector]_QueueOffset(\"_QueueOffset\", Float) = 0\n      [HideInInspector]_QueueControl(\"_QueueControl\", Float) = -1\n      [HideInInspector][NoScaleOffset]unity_Lightmaps(\"unity_Lightmaps\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_LightmapsInd(\"unity_LightmapsInd\", 2DArray) = \"\" {}\n      [HideInInspector][NoScaleOffset]unity_ShadowMasks(\"unity_ShadowMasks\", 2DArray) = \"\" {}\n      \n\n    [BetterHeader(Material Specific)]\n    _Color (\"Main Color\", Color) = (1, 1, 1, 1)\n\t_ColorModulation (\"Color Modulation\", Range(0,2)) = 1\n\t_MetallicModulation (\"Metallic Level\", Range(0,2)) = 1\n\t_SmoothnessModulation (\"Smoothness Level\", Range(0,2)) = 1\n\t[BetterHeader(Lighting Adjustment)]\n    [Toggle]_UseHalfLambert (\"Use Half Lambert\", Float) = 0\n    _HalfLambertStrength (\"Lambert(0), HalfLambert(1)\", Range(0,16)) = 1\n    _RimLightingModulation (\"Rim Lighting Level\", Float) = 0\n\t_RimLightColor(\"Rim Light Color\", Color) = (1,1,1,1)\n\t_RimLightPower(\"Rim Light Power\", Range(0.5, 12)) = 4\n\n    [Enum(Off,0,Front,1,Back,2)]_CullMode(\"Culling Mode\", Float) = 2\n    [Enum(Flip, 0, Mirror, 1, None, 2)] _DoubleSidedNormalMode(\"Double sided normal mode\", Float) = 1\n\n    _BaseMap(\"BaseMap\", 2D) = \"white\" {}\n    _BumpMap(\"_BumpMap\", 2D) = \"bump\" {}\n    _NormalStrength (\"Normal Strength\", Range(0,2)) = 1\n    _MetallicGlossMap(\"_MetallicGlossMap\", 2D) = \"black\" {}\n    _UberTile(\"Uber Tile\", Range(0,16)) = 1\n\n\n\n   }\n   SubShader\n   {\n      Tags { \"RenderPipeline\"=\"UniversalPipeline\" \"RenderType\" = \"Opaque\" \"UniversalMaterialType\" = \"Lit\" \"Queue\" = \"Geometry\" }\n\n      \n\n      \n        Pass\n        {\n            Name \"Universal Forward\"\n            Tags \n            { \n                \"LightMode\" = \"UniversalForward\"\n            }\n            Cull Back\n            Blend One Zero\n            ZTest LEqual\n            ZWrite On\n\n            Blend One Zero, One Zero\nCull Back\nZTest LEqual\nZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n            #pragma instancing_options renderinglayer\n    \n            // Keywords\n            #pragma multi_compile_fragment _ _SCREEN_SPACE_OCCLUSION\n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\n            #pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS\n            #pragma multi_compile_fragment _ _ADDITIONAL_LIGHT_SHADOWS\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT_LOW\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT_MEDIUM\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT_HIGH\n            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3\n            #pragma multi_compile_fragment _ _LIGHT_LAYERS\n            #pragma multi_compile_fragment _ DEBUG_DISPLAY\n            #pragma multi_compile_fragment _ _LIGHT_COOKIES\n            #pragma multi_compile _ _FORWARD_PLUS\n            #pragma multi_compile _ EVALUATE_SH_VERTEX\n            #pragma multi_compile _ EVALUATE_SH_MIXED\n            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE\n\n        \n            // GraphKeywords: <None>\n\n            #define SHADER_PASS SHADERPASS_FORWARD\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define _PASSFORWARD 1\n            #define _FOG_FRAGMENT 1\n            \n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n          \n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/RenderingLayers.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ProbeVolumeVariants.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DBuffer.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl\"\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float4 probeOcclusion : TEXCOORD8;\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n         #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n            float4 previousPositionCS : TEXCOORD21; // Contain previous transform position (in case of skinning for example)\n            float4 positionCS : TEXCOORD22;\n         #endif\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n            #define GetWorldToViewMatrix()     _ViewMatrix\n            #define UNITY_MATRIX_I_V   _InvViewMatrix\n            #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(_ProjMatrix)\n            #define UNITY_MATRIX_I_P   _InvProjMatrix\n            #define GetWorldToHClipMatrix()    _ViewProjMatrix\n            #define UNITY_MATRIX_I_VP  _InvViewProjMatrix\n            #define UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix\n            #define UNITY_MATRIX_PREV_VP _PrevViewProjMatrix\n            #define UNITY_MATRIX_PREV_I_VP _PrevInvViewProjMatrix\n\n            void MotionVectorPositionZBias(VertexToPixel input)\n            {\n                #if UNITY_REVERSED_Z\n                input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n                #else\n                input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n                #endif\n            }\n\n        #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n            \n           #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n             VertexData previousMesh = v;\n           #endif\n           #if !_TESSELLATION_ON\n             ChainModifyVertex(v, o, _Time);\n           #endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // This return the camera relative position (if enable)\n           float3 positionWS = TransformObjectToWorld(v.vertex.xyz);\n           float3 normalWS = TransformObjectToWorldNormal(v.normal);\n           float4 tangentWS = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = positionWS;\n           o.worldNormal = normalWS;\n           o.worldTangent = tangentWS;\n\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          \n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              #if UNITY_VERSION < 60000009\n                OUTPUT_SH(o.worldNormal, o.sh);\n              #endif\n              \n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n                   #if UNITY_VERSION >= 60000009\n                     OUTPUT_SH(o.worldNormal, o.sh);\n                   #endif\n              #elif (defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)) && UNITY_VERSION >= 60000009\n                   OUTPUT_SH4(vertexInput.positionWS, o.worldNormal.xyz, GetWorldSpaceNormalizeViewDir(vertexInput.positionWS), o.sh, o.probeOcclusion);\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n            #if !defined(TESSELLATION_ON)\n              MotionVectorPositionZBias(o);\n            #endif\n\n            o.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n            // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n            bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n            if (!forceNoMotion)\n            {\n              #if defined(HAVE_VFX_MODIFICATION)\n                float3 previousPositionOS = currentFrameMvData.vfxParticlePositionOS;\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  const bool applyDeformation = false;\n                #else\n                  const bool applyDeformation = true;\n                #endif\n              #else\n                const bool hasDeformation = unity_MotionVectorsParams.x == 1; // Mesh has skinned deformation\n                float3 previousPositionOS = hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz;\n\n                #if defined(AUTOMATIC_TIME_BASED_MOTION_VECTORS) && defined(GRAPH_VERTEX_USES_TIME_PARAMETERS_INPUT)\n                  const bool applyDeformation = true;\n                #else\n                  const bool applyDeformation = hasDeformation;\n                #endif\n              #endif\n              // TODO\n              #if defined(FEATURES_GRAPH_VERTEX)\n                if (applyDeformation)\n                  previousPositionOS = GetLastFrameDeformedPosition(previousMesh, currentFrameMvData, previousPositionOS);\n                else\n                  previousPositionOS = previousMesh.positionOS;\n\n                #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT)\n                  previousPositionOS -= previousMesh.precomputedVelocity;\n                #endif\n              #endif\n\n              #if defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(DOTS_DEFORMED)\n                // Deformed vertices in DOTS are not cumulative with built-in Unity skinning/blend shapes\n                // Needs to be called after vertex modification has been applied otherwise it will be\n                // overwritten by Compute Deform node\n                ApplyPreviousFrameDeformedVertexPosition(previousMesh.vertexID, previousPositionOS);\n              #endif\n              #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                previousPositionOS -= previousMesh.precomputedVelocity;\n              #endif\n              o.positionCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionWS, 1.0f));\n\n              #if defined(HAVE_VFX_MODIFICATION)\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT) || defined(_ADD_PRECOMPUTED_VELOCITY)\n                    #error Unexpected fast path rendering VFX motion vector while there are vertex modification afterwards.\n                  #endif\n                  o.previousPositionCS = VFXGetPreviousClipPosition(previousMesh, currentFrameMvData.vfxElementAttributes, o.positionCS);\n                #else\n                  #if VFX_WORLD_SPACE\n                    //previousPositionOS is already in world space\n                    const float3 previousPositionWS = previousPositionOS;\n                  #else\n                    const float3 previousPositionWS = mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1.0f)).xyz;\n                  #endif\n                  o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionWS, 1.0f));\n                #endif\n              #else\n                o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1)));\n              #endif\n            }\n          #endif\n\n          return o;\n         }\n\n\n         \n\n#if _UNLIT\n   #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Unlit.hlsl\"  \n#endif\n\n         // fragment shader\n         void Frag (VertexToPixel IN\n              , out half4 outColor : SV_Target0\n            #ifdef _WRITE_RENDERING_LAYERS\n              , out float4 outRenderingLayers : SV_Target1\n            #endif\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         )\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           #if defined(LOD_FADE_CROSSFADE)\n              LODFadeCrossFade(IN.pos);\n           #endif\n\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n           #if _USESPECULAR || _SIMPLELIT\n              float3 specular = l.Specular;\n              float metallic = 1;\n           #else   \n              float3 specular = 0;\n              float metallic = l.Metallic;\n           #endif\n\n\n            \n           \n            InputData inputData = (InputData)0;\n\n            inputData.positionWS = IN.worldPos;\n            #if _WORLDSPACENORMAL\n              inputData.normalWS = l.Normal;\n            #else\n              inputData.normalWS = normalize(TangentToWorldSpace(d, l.Normal));\n            #endif\n\n            inputData.viewDirectionWS = SafeNormalize(d.worldSpaceViewDir);\n\n\n            #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n                  inputData.shadowCoord = IN.shadowCoord;\n            #elif defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                  inputData.shadowCoord = TransformWorldToShadowCoord(IN.worldPos);\n            #else\n                  inputData.shadowCoord = float4(0, 0, 0, 0);\n            #endif\n            \n#if _BAKEDLIT\n            inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n            inputData.vertexLighting = 0;\n#else\n            inputData.fogCoord = InitializeInputDataFog(float4(IN.worldPos, 1.0), IN.fogFactorAndVertexLight.x);\n            inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n#endif    \n\n\n\n            #if defined(_OVERRIDE_BAKEDGI)\n               inputData.bakedGI = l.DiffuseGI;\n               l.Emission += l.SpecularGI;\n            #elif _BAKEDLIT\n               inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n            #else\n               #if defined(DYNAMICLIGHTMAP_ON)\n                  inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.dynamicLightmapUV.xy, IN.sh, inputData.normalWS);\n               #elif defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)\n               #if UNITY_VERSION >= 60000009\n                  inputData.bakedGI = SAMPLE_GI(IN.sh, IN.worldPos, inputData.normalWS, inputData.viewDirectionWS, IN.pos, IN.probeOcclusion, inputData.shadowMask);\n               #else\n                  inputData.bakedGI = SAMPLE_GI(IN.sh, IN.worldPos, inputData.normalWS, inputData.viewDirectionWS, IN.pos);\n               #endif\n               #else\n                  inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n               #endif\n            #endif\n            inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n            #if !_BAKEDLIT\n               inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n           \n               #if defined(_OVERRIDE_SHADOWMASK)\n                  float4 mulColor = saturate(dot(l.ShadowMask, _MainLightOcclusionProbes)); //unity_OcclusionMaskSelector));\n                  inputData.shadowMask = mulColor;\n               #endif\n            #else\n               inputData.shadowMask = float4(1,1,1,1);\n            #endif\n\n            #if defined(DEBUG_DISPLAY)\n                #if defined(DYNAMICLIGHTMAP_ON)\n                  inputData.dynamicLightmapUV = IN.dynamicLightmapUV.xy;\n                #endif\n                #if defined(LIGHTMAP_ON)\n                  inputData.staticLightmapUV = IN.lightmapUV;\n                #else\n                  inputData.vertexSH = IN.sh;\n                #endif\n            #endif\n\n            #if _WORLDSPACENORMAL\n              float3 normalTS = WorldToTangentSpace(d, l.Normal);\n            #else\n              float3 normalTS = l.Normal;\n            #endif\n\n            SurfaceData surface         = (SurfaceData)0;\n            surface.albedo              = l.Albedo;\n            surface.metallic            = saturate(metallic);\n            surface.specular            = specular;\n            surface.smoothness          = saturate(l.Smoothness),\n            surface.occlusion           = l.Occlusion,\n            surface.emission            = l.Emission,\n            surface.alpha               = saturate(l.Alpha);\n            surface.clearCoatMask       = 0;\n            surface.clearCoatSmoothness = 1;\n\n            #ifdef _CLEARCOAT\n                  surface.clearCoatMask       = saturate(l.CoatMask);\n                  surface.clearCoatSmoothness = saturate(l.CoatSmoothness);\n            #endif\n\n            #if !_UNLIT\n               half4 color = half4(l.Albedo, l.Alpha);\n               #ifdef _DBUFFER\n                  #if _BAKEDLIT\n                     half3 bakeColor = color.rgb;\n                     float3 bakeNormal = inputData.normalWS.xyz;\n                     ApplyDecalToBaseColorAndNormal(IN.pos, bakeColor, bakeNormal);\n                     color.rgb = bakeColor;\n                     inputData.normalWS.xyz = bakeNormal;\n                  #else\n                     ApplyDecalToSurfaceData(IN.pos, surface, inputData);\n                  #endif\n               #endif\n               #if _SIMPLELIT\n                  color = UniversalFragmentBlinnPhong(\n                     inputData,\n                     surface);\n               #elif _BAKEDLIT\n                  color = UniversalFragmentBakedLit(inputData, color.rgb, color.a, normalTS);\n               #else\n                  color = UniversalFragmentPBR(inputData, surface);\n               #endif\n\n               #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n               #endif\n\n            #else // unlit\n               #ifdef _DBUFFER\n                  ApplyDecalToSurfaceData(IN.pos, surface, inputData);\n               #endif\n               half4 color = UniversalFragmentUnlit(inputData, l.Albedo, l.Alpha);\n               #if !DISABLEFOG\n                  color.rgb = MixFog(color.rgb, inputData.fogCoord);\n               #endif\n            #endif\n            ChainFinalColorForward(l, d, color);\n\n            outColor = color;\n\n            #ifdef _WRITE_RENDERING_LAYERS\n                uint renderingLayers = GetMeshRenderingLayer();\n                outRenderingLayers = float4(EncodeMeshRenderingLayer(renderingLayers), 0, 0, 0);\n            #endif\n\n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"GBuffer\"\n            Tags\n            {\n               \"LightMode\" = \"UniversalGBuffer\"\n            }\n           \n             Blend One Zero\n             ZTest LEqual\n             ZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n            #pragma multi_compile_fog\n            #pragma instancing_options renderinglayer\n            \n            #pragma multi_compile _ LIGHTMAP_ON\n            #pragma multi_compile _ DYNAMICLIGHTMAP_ON\n            #pragma multi_compile _ DIRLIGHTMAP_COMBINED\n            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS _MAIN_LIGHT_SHADOWS_CASCADE _MAIN_LIGHT_SHADOWS_SCREEN\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BLENDING\n            #pragma multi_compile_fragment _ _REFLECTION_PROBE_BOX_PROJECTION\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT_LOW\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT_MEDIUM\n            #pragma multi_compile_fragment _ _SHADOWS_SOFT_HIGH\n            #pragma multi_compile _ LIGHTMAP_SHADOW_MIXING\n            #pragma multi_compile _ SHADOWS_SHADOWMASK\n            #pragma multi_compile _ _MIXED_LIGHTING_SUBTRACTIVE\n            #pragma multi_compile_fragment _ _DBUFFER_MRT1 _DBUFFER_MRT2 _DBUFFER_MRT3\n            #pragma multi_compile_fragment _ _GBUFFER_NORMALS_OCT\n            #pragma multi_compile_fragment _ _RENDER_PASS_ENABLED\n            #pragma multi_compile_fragment _ DEBUG_DISPLAY\n            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE\n  \n\n            #define _FOG_FRAGMENT 1\n\n            #define VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n            #define SHADERPASS SHADERPASS_GBUFFER\n            #define _PASSGBUFFER 1\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            \n\n            // Includes\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/RenderingLayers.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ProbeVolumeVariants.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Shadows.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DBuffer.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl\"\n\n            \n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float4 probeOcclusion : TEXCOORD8;\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n         #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n            float4 previousPositionCS : TEXCOORD21; // Contain previous transform position (in case of skinning for example)\n            float4 positionCS : TEXCOORD22;\n         #endif\n      };\n\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n            #define GetWorldToViewMatrix()     _ViewMatrix\n            #define UNITY_MATRIX_I_V   _InvViewMatrix\n            #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(_ProjMatrix)\n            #define UNITY_MATRIX_I_P   _InvProjMatrix\n            #define GetWorldToHClipMatrix()    _ViewProjMatrix\n            #define UNITY_MATRIX_I_VP  _InvViewProjMatrix\n            #define UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix\n            #define UNITY_MATRIX_PREV_VP _PrevViewProjMatrix\n            #define UNITY_MATRIX_PREV_I_VP _PrevInvViewProjMatrix\n\n            void MotionVectorPositionZBias(VertexToPixel input)\n            {\n                #if UNITY_REVERSED_Z\n                input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n                #else\n                input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n                #endif\n            }\n\n        #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n            \n           #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n             VertexData previousMesh = v;\n           #endif\n           #if !_TESSELLATION_ON\n             ChainModifyVertex(v, o, _Time);\n           #endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // This return the camera relative position (if enable)\n           float3 positionWS = TransformObjectToWorld(v.vertex.xyz);\n           float3 normalWS = TransformObjectToWorldNormal(v.normal);\n           float4 tangentWS = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = positionWS;\n           o.worldNormal = normalWS;\n           o.worldTangent = tangentWS;\n\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          \n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              #if UNITY_VERSION < 60000009\n                OUTPUT_SH(o.worldNormal, o.sh);\n              #endif\n              \n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n                   #if UNITY_VERSION >= 60000009\n                     OUTPUT_SH(o.worldNormal, o.sh);\n                   #endif\n              #elif (defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)) && UNITY_VERSION >= 60000009\n                   OUTPUT_SH4(vertexInput.positionWS, o.worldNormal.xyz, GetWorldSpaceNormalizeViewDir(vertexInput.positionWS), o.sh, o.probeOcclusion);\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n            #if !defined(TESSELLATION_ON)\n              MotionVectorPositionZBias(o);\n            #endif\n\n            o.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n            // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n            bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n            if (!forceNoMotion)\n            {\n              #if defined(HAVE_VFX_MODIFICATION)\n                float3 previousPositionOS = currentFrameMvData.vfxParticlePositionOS;\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  const bool applyDeformation = false;\n                #else\n                  const bool applyDeformation = true;\n                #endif\n              #else\n                const bool hasDeformation = unity_MotionVectorsParams.x == 1; // Mesh has skinned deformation\n                float3 previousPositionOS = hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz;\n\n                #if defined(AUTOMATIC_TIME_BASED_MOTION_VECTORS) && defined(GRAPH_VERTEX_USES_TIME_PARAMETERS_INPUT)\n                  const bool applyDeformation = true;\n                #else\n                  const bool applyDeformation = hasDeformation;\n                #endif\n              #endif\n              // TODO\n              #if defined(FEATURES_GRAPH_VERTEX)\n                if (applyDeformation)\n                  previousPositionOS = GetLastFrameDeformedPosition(previousMesh, currentFrameMvData, previousPositionOS);\n                else\n                  previousPositionOS = previousMesh.positionOS;\n\n                #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT)\n                  previousPositionOS -= previousMesh.precomputedVelocity;\n                #endif\n              #endif\n\n              #if defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(DOTS_DEFORMED)\n                // Deformed vertices in DOTS are not cumulative with built-in Unity skinning/blend shapes\n                // Needs to be called after vertex modification has been applied otherwise it will be\n                // overwritten by Compute Deform node\n                ApplyPreviousFrameDeformedVertexPosition(previousMesh.vertexID, previousPositionOS);\n              #endif\n              #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                previousPositionOS -= previousMesh.precomputedVelocity;\n              #endif\n              o.positionCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionWS, 1.0f));\n\n              #if defined(HAVE_VFX_MODIFICATION)\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT) || defined(_ADD_PRECOMPUTED_VELOCITY)\n                    #error Unexpected fast path rendering VFX motion vector while there are vertex modification afterwards.\n                  #endif\n                  o.previousPositionCS = VFXGetPreviousClipPosition(previousMesh, currentFrameMvData.vfxElementAttributes, o.positionCS);\n                #else\n                  #if VFX_WORLD_SPACE\n                    //previousPositionOS is already in world space\n                    const float3 previousPositionWS = previousPositionOS;\n                  #else\n                    const float3 previousPositionWS = mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1.0f)).xyz;\n                  #endif\n                  o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionWS, 1.0f));\n                #endif\n              #else\n                o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1)));\n              #endif\n            }\n          #endif\n\n          return o;\n         }\n\n\n            \n\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/UnityGBuffer.hlsl\"\n\n            // fragment shader\n            FragmentOutput Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) \n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n               #if defined(LOD_FADE_CROSSFADE)\n                  LODFadeCrossFade(IN.pos);\n               #endif\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n               #if _USESPECULAR || _SIMPLELIT\n                  float3 specular = l.Specular;\n                  float metallic = 0;\n               #else   \n                  float3 specular = 0;\n                  float metallic = l.Metallic;\n               #endif\n\n               InputData inputData = (InputData)0;\n\n               inputData.positionWS = IN.worldPos;\n               #if _WORLDSPACENORMAL\n                  inputData.normalWS = l.Normal;\n               #else\n                  inputData.normalWS = normalize(TangentToWorldSpace(d, l.Normal));\n               #endif\n\n               inputData.viewDirectionWS = SafeNormalize(d.worldSpaceViewDir);\n\n\n               #if defined(MAIN_LIGHT_CALCULATE_SHADOWS)\n                   inputData.shadowCoord = TransformWorldToShadowCoord(inputData.positionWS);\n               #else\n                   inputData.shadowCoord = float4(0, 0, 0, 0);\n               #endif\n\n               //inputData.fogCoord = IN.fogFactorAndVertexLight.x;\n               InitializeInputDataFog(float4(IN.worldPos, 1.0), IN.fogFactorAndVertexLight.x);\n               inputData.vertexLighting = IN.fogFactorAndVertexLight.yzw;\n\n\n               #if defined(_OVERRIDE_BAKEDGI)\n                  inputData.bakedGI = l.DiffuseGI;\n                  l.Emission += l.SpecularGI;\n               #else\n                  #if defined(DYNAMICLIGHTMAP_ON)\n                    inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.dynamicLightmapUV.xy, IN.sh, inputData.normalWS);\n\t\t            #elif defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)\n                  #if UNITY_VERSION >= 60000009\n                     inputData.bakedGI = SAMPLE_GI(IN.sh, IN.worldPos, inputData.normalWS, inputData.viewDirectionWS, IN.pos, IN.probeOcclusion, inputData.shadowMask);\n                  #else\n                     inputData.bakedGI = SAMPLE_GI(IN.sh, IN.worldPos, inputData.normalWS, inputData.viewDirectionWS, IN.pos);\n                  #endif\n                  #else\n                    inputData.bakedGI = SAMPLE_GI(IN.lightmapUV, IN.sh, inputData.normalWS);\n                  #endif\n               #endif\n\n               inputData.normalizedScreenSpaceUV = GetNormalizedScreenSpaceUV(IN.pos);\n               inputData.shadowMask = SAMPLE_SHADOWMASK(IN.lightmapUV);\n\n               #if defined(DEBUG_DISPLAY)\n                   #if defined(DYNAMICLIGHTMAP_ON)\n                     inputData.dynamicLightmapUV = IN.dynamicLightmapUV.xy;\n                   #endif\n                   #if defined(LIGHTMAP_ON)\n                     inputData.staticLightmapUV = IN.lightmapUV;\n                   #else\n                     inputData.vertexSH = IN.sh;\n                   #endif\n               #endif\n\n               #ifdef _DBUFFER\n                   ApplyDecal(IN.pos,\n                       l.Albedo,\n                       specular,\n                       inputData.normalWS,\n                       metallic,\n                       l.Occlusion,\n                       l.Smoothness);\n               #endif\n\n               BRDFData brdfData;\n               InitializeBRDFData(l.Albedo, metallic, specular, l.Smoothness, l.Alpha, brdfData);\n               Light mainLight = GetMainLight(inputData.shadowCoord, inputData.positionWS, inputData.shadowMask);\n               MixRealtimeAndBakedGI(mainLight, inputData.normalWS, inputData.bakedGI, inputData.shadowMask);\n               half3 color = GlobalIllumination(brdfData, inputData.bakedGI, l.Occlusion, inputData.positionWS, inputData.normalWS, inputData.viewDirectionWS);\n\n               return BRDFDataToGbuffer(brdfData, inputData, l.Smoothness, l.Emission + color, l.Occlusion);\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"ShadowCaster\"\n            Tags \n            { \n                \"LightMode\" = \"ShadowCaster\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            // ColorMask: <None>\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n  \n            #pragma multi_compile_vertex _ _CASTING_PUNCTUAL_LIGHT_SHADOW\n            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE\n\n            #define _NORMAL_DROPOFF_TS 1\n            #define ATTRIBUTES_NEED_NORMAL\n            #define ATTRIBUTES_NEED_TANGENT\n            #define _PASSSHADOW 1\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl\"\n            \n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float4 probeOcclusion : TEXCOORD8;\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n         #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n            float4 previousPositionCS : TEXCOORD21; // Contain previous transform position (in case of skinning for example)\n            float4 positionCS : TEXCOORD22;\n         #endif\n      };\n\n         \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n            #define GetWorldToViewMatrix()     _ViewMatrix\n            #define UNITY_MATRIX_I_V   _InvViewMatrix\n            #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(_ProjMatrix)\n            #define UNITY_MATRIX_I_P   _InvProjMatrix\n            #define GetWorldToHClipMatrix()    _ViewProjMatrix\n            #define UNITY_MATRIX_I_VP  _InvViewProjMatrix\n            #define UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix\n            #define UNITY_MATRIX_PREV_VP _PrevViewProjMatrix\n            #define UNITY_MATRIX_PREV_I_VP _PrevInvViewProjMatrix\n\n            void MotionVectorPositionZBias(VertexToPixel input)\n            {\n                #if UNITY_REVERSED_Z\n                input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n                #else\n                input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n                #endif\n            }\n\n        #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n            \n           #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n             VertexData previousMesh = v;\n           #endif\n           #if !_TESSELLATION_ON\n             ChainModifyVertex(v, o, _Time);\n           #endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // This return the camera relative position (if enable)\n           float3 positionWS = TransformObjectToWorld(v.vertex.xyz);\n           float3 normalWS = TransformObjectToWorldNormal(v.normal);\n           float4 tangentWS = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = positionWS;\n           o.worldNormal = normalWS;\n           o.worldTangent = tangentWS;\n\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          \n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              #if UNITY_VERSION < 60000009\n                OUTPUT_SH(o.worldNormal, o.sh);\n              #endif\n              \n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n                   #if UNITY_VERSION >= 60000009\n                     OUTPUT_SH(o.worldNormal, o.sh);\n                   #endif\n              #elif (defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)) && UNITY_VERSION >= 60000009\n                   OUTPUT_SH4(vertexInput.positionWS, o.worldNormal.xyz, GetWorldSpaceNormalizeViewDir(vertexInput.positionWS), o.sh, o.probeOcclusion);\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n            #if !defined(TESSELLATION_ON)\n              MotionVectorPositionZBias(o);\n            #endif\n\n            o.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n            // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n            bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n            if (!forceNoMotion)\n            {\n              #if defined(HAVE_VFX_MODIFICATION)\n                float3 previousPositionOS = currentFrameMvData.vfxParticlePositionOS;\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  const bool applyDeformation = false;\n                #else\n                  const bool applyDeformation = true;\n                #endif\n              #else\n                const bool hasDeformation = unity_MotionVectorsParams.x == 1; // Mesh has skinned deformation\n                float3 previousPositionOS = hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz;\n\n                #if defined(AUTOMATIC_TIME_BASED_MOTION_VECTORS) && defined(GRAPH_VERTEX_USES_TIME_PARAMETERS_INPUT)\n                  const bool applyDeformation = true;\n                #else\n                  const bool applyDeformation = hasDeformation;\n                #endif\n              #endif\n              // TODO\n              #if defined(FEATURES_GRAPH_VERTEX)\n                if (applyDeformation)\n                  previousPositionOS = GetLastFrameDeformedPosition(previousMesh, currentFrameMvData, previousPositionOS);\n                else\n                  previousPositionOS = previousMesh.positionOS;\n\n                #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT)\n                  previousPositionOS -= previousMesh.precomputedVelocity;\n                #endif\n              #endif\n\n              #if defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(DOTS_DEFORMED)\n                // Deformed vertices in DOTS are not cumulative with built-in Unity skinning/blend shapes\n                // Needs to be called after vertex modification has been applied otherwise it will be\n                // overwritten by Compute Deform node\n                ApplyPreviousFrameDeformedVertexPosition(previousMesh.vertexID, previousPositionOS);\n              #endif\n              #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                previousPositionOS -= previousMesh.precomputedVelocity;\n              #endif\n              o.positionCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionWS, 1.0f));\n\n              #if defined(HAVE_VFX_MODIFICATION)\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT) || defined(_ADD_PRECOMPUTED_VELOCITY)\n                    #error Unexpected fast path rendering VFX motion vector while there are vertex modification afterwards.\n                  #endif\n                  o.previousPositionCS = VFXGetPreviousClipPosition(previousMesh, currentFrameMvData.vfxElementAttributes, o.positionCS);\n                #else\n                  #if VFX_WORLD_SPACE\n                    //previousPositionOS is already in world space\n                    const float3 previousPositionWS = previousPositionOS;\n                  #else\n                    const float3 previousPositionWS = mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1.0f)).xyz;\n                  #endif\n                  o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionWS, 1.0f));\n                #endif\n              #else\n                o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1)));\n              #endif\n            }\n          #endif\n\n          return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               #if defined(LOD_FADE_CROSSFADE)\n                  LODFadeCrossFade(IN.pos);\n               #endif\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n             return 0;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"DepthOnly\"\n            Tags \n            { \n                \"LightMode\" = \"DepthOnly\"\n            }\n           \n            // Render State\n            Blend One Zero, One Zero\n            Cull Back\n            ZTest LEqual\n            ZWrite On\n            ColorMask 0\n            \n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n\n            #define _PASSDEPTH 1\n\n            #pragma target 3.0\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_instancing\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n            // Includes\n            //#include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            //#include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float4 probeOcclusion : TEXCOORD8;\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n         #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n            float4 previousPositionCS : TEXCOORD21; // Contain previous transform position (in case of skinning for example)\n            float4 positionCS : TEXCOORD22;\n         #endif\n      };\n\n         \n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n            #define GetWorldToViewMatrix()     _ViewMatrix\n            #define UNITY_MATRIX_I_V   _InvViewMatrix\n            #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(_ProjMatrix)\n            #define UNITY_MATRIX_I_P   _InvProjMatrix\n            #define GetWorldToHClipMatrix()    _ViewProjMatrix\n            #define UNITY_MATRIX_I_VP  _InvViewProjMatrix\n            #define UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix\n            #define UNITY_MATRIX_PREV_VP _PrevViewProjMatrix\n            #define UNITY_MATRIX_PREV_I_VP _PrevInvViewProjMatrix\n\n            void MotionVectorPositionZBias(VertexToPixel input)\n            {\n                #if UNITY_REVERSED_Z\n                input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n                #else\n                input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n                #endif\n            }\n\n        #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n            \n           #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n             VertexData previousMesh = v;\n           #endif\n           #if !_TESSELLATION_ON\n             ChainModifyVertex(v, o, _Time);\n           #endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // This return the camera relative position (if enable)\n           float3 positionWS = TransformObjectToWorld(v.vertex.xyz);\n           float3 normalWS = TransformObjectToWorldNormal(v.normal);\n           float4 tangentWS = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = positionWS;\n           o.worldNormal = normalWS;\n           o.worldTangent = tangentWS;\n\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          \n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              #if UNITY_VERSION < 60000009\n                OUTPUT_SH(o.worldNormal, o.sh);\n              #endif\n              \n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n                   #if UNITY_VERSION >= 60000009\n                     OUTPUT_SH(o.worldNormal, o.sh);\n                   #endif\n              #elif (defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)) && UNITY_VERSION >= 60000009\n                   OUTPUT_SH4(vertexInput.positionWS, o.worldNormal.xyz, GetWorldSpaceNormalizeViewDir(vertexInput.positionWS), o.sh, o.probeOcclusion);\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n            #if !defined(TESSELLATION_ON)\n              MotionVectorPositionZBias(o);\n            #endif\n\n            o.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n            // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n            bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n            if (!forceNoMotion)\n            {\n              #if defined(HAVE_VFX_MODIFICATION)\n                float3 previousPositionOS = currentFrameMvData.vfxParticlePositionOS;\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  const bool applyDeformation = false;\n                #else\n                  const bool applyDeformation = true;\n                #endif\n              #else\n                const bool hasDeformation = unity_MotionVectorsParams.x == 1; // Mesh has skinned deformation\n                float3 previousPositionOS = hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz;\n\n                #if defined(AUTOMATIC_TIME_BASED_MOTION_VECTORS) && defined(GRAPH_VERTEX_USES_TIME_PARAMETERS_INPUT)\n                  const bool applyDeformation = true;\n                #else\n                  const bool applyDeformation = hasDeformation;\n                #endif\n              #endif\n              // TODO\n              #if defined(FEATURES_GRAPH_VERTEX)\n                if (applyDeformation)\n                  previousPositionOS = GetLastFrameDeformedPosition(previousMesh, currentFrameMvData, previousPositionOS);\n                else\n                  previousPositionOS = previousMesh.positionOS;\n\n                #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT)\n                  previousPositionOS -= previousMesh.precomputedVelocity;\n                #endif\n              #endif\n\n              #if defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(DOTS_DEFORMED)\n                // Deformed vertices in DOTS are not cumulative with built-in Unity skinning/blend shapes\n                // Needs to be called after vertex modification has been applied otherwise it will be\n                // overwritten by Compute Deform node\n                ApplyPreviousFrameDeformedVertexPosition(previousMesh.vertexID, previousPositionOS);\n              #endif\n              #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                previousPositionOS -= previousMesh.precomputedVelocity;\n              #endif\n              o.positionCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionWS, 1.0f));\n\n              #if defined(HAVE_VFX_MODIFICATION)\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT) || defined(_ADD_PRECOMPUTED_VELOCITY)\n                    #error Unexpected fast path rendering VFX motion vector while there are vertex modification afterwards.\n                  #endif\n                  o.previousPositionCS = VFXGetPreviousClipPosition(previousMesh, currentFrameMvData.vfxElementAttributes, o.positionCS);\n                #else\n                  #if VFX_WORLD_SPACE\n                    //previousPositionOS is already in world space\n                    const float3 previousPositionWS = previousPositionOS;\n                  #else\n                    const float3 previousPositionWS = mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1.0f)).xyz;\n                  #endif\n                  o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionWS, 1.0f));\n                #endif\n              #else\n                o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1)));\n              #endif\n            }\n          #endif\n\n          return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n               UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n                #if defined(LOD_FADE_CROSSFADE) && USE_UNITY_CROSSFADE\n                    LODFadeCrossFade(IN.pos);\n                #endif\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n               Surface l = (Surface)0;\n\n               #ifdef _DEPTHOFFSET_ON\n                  l.outputDepth = outputDepth;\n               #endif\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               #ifdef _DEPTHOFFSET_ON\n                  outputDepth = l.outputDepth;\n               #endif\n\n               return 0;\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"Meta\"\n            Tags \n            { \n                \"LightMode\" = \"Meta\"\n            }\n\n            Cull Off\n            \n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n        \n            #define SHADERPASS SHADERPASS_META\n            #define _PASSMETA 1\n\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n\n            // Includes\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/MetaInput.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n\n                  #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float4 probeOcclusion : TEXCOORD8;\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n         #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n            float4 previousPositionCS : TEXCOORD21; // Contain previous transform position (in case of skinning for example)\n            float4 positionCS : TEXCOORD22;\n         #endif\n      };\n\n\n            \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n            CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n            CBUFFER_END\n\n            \n\n            \n\n            \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n            \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n            \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n            #define GetWorldToViewMatrix()     _ViewMatrix\n            #define UNITY_MATRIX_I_V   _InvViewMatrix\n            #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(_ProjMatrix)\n            #define UNITY_MATRIX_I_P   _InvProjMatrix\n            #define GetWorldToHClipMatrix()    _ViewProjMatrix\n            #define UNITY_MATRIX_I_VP  _InvViewProjMatrix\n            #define UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix\n            #define UNITY_MATRIX_PREV_VP _PrevViewProjMatrix\n            #define UNITY_MATRIX_PREV_I_VP _PrevInvViewProjMatrix\n\n            void MotionVectorPositionZBias(VertexToPixel input)\n            {\n                #if UNITY_REVERSED_Z\n                input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n                #else\n                input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n                #endif\n            }\n\n        #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n            \n           #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n             VertexData previousMesh = v;\n           #endif\n           #if !_TESSELLATION_ON\n             ChainModifyVertex(v, o, _Time);\n           #endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // This return the camera relative position (if enable)\n           float3 positionWS = TransformObjectToWorld(v.vertex.xyz);\n           float3 normalWS = TransformObjectToWorldNormal(v.normal);\n           float4 tangentWS = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = positionWS;\n           o.worldNormal = normalWS;\n           o.worldTangent = tangentWS;\n\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          \n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              #if UNITY_VERSION < 60000009\n                OUTPUT_SH(o.worldNormal, o.sh);\n              #endif\n              \n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n                   #if UNITY_VERSION >= 60000009\n                     OUTPUT_SH(o.worldNormal, o.sh);\n                   #endif\n              #elif (defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)) && UNITY_VERSION >= 60000009\n                   OUTPUT_SH4(vertexInput.positionWS, o.worldNormal.xyz, GetWorldSpaceNormalizeViewDir(vertexInput.positionWS), o.sh, o.probeOcclusion);\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n            #if !defined(TESSELLATION_ON)\n              MotionVectorPositionZBias(o);\n            #endif\n\n            o.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n            // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n            bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n            if (!forceNoMotion)\n            {\n              #if defined(HAVE_VFX_MODIFICATION)\n                float3 previousPositionOS = currentFrameMvData.vfxParticlePositionOS;\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  const bool applyDeformation = false;\n                #else\n                  const bool applyDeformation = true;\n                #endif\n              #else\n                const bool hasDeformation = unity_MotionVectorsParams.x == 1; // Mesh has skinned deformation\n                float3 previousPositionOS = hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz;\n\n                #if defined(AUTOMATIC_TIME_BASED_MOTION_VECTORS) && defined(GRAPH_VERTEX_USES_TIME_PARAMETERS_INPUT)\n                  const bool applyDeformation = true;\n                #else\n                  const bool applyDeformation = hasDeformation;\n                #endif\n              #endif\n              // TODO\n              #if defined(FEATURES_GRAPH_VERTEX)\n                if (applyDeformation)\n                  previousPositionOS = GetLastFrameDeformedPosition(previousMesh, currentFrameMvData, previousPositionOS);\n                else\n                  previousPositionOS = previousMesh.positionOS;\n\n                #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT)\n                  previousPositionOS -= previousMesh.precomputedVelocity;\n                #endif\n              #endif\n\n              #if defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(DOTS_DEFORMED)\n                // Deformed vertices in DOTS are not cumulative with built-in Unity skinning/blend shapes\n                // Needs to be called after vertex modification has been applied otherwise it will be\n                // overwritten by Compute Deform node\n                ApplyPreviousFrameDeformedVertexPosition(previousMesh.vertexID, previousPositionOS);\n              #endif\n              #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                previousPositionOS -= previousMesh.precomputedVelocity;\n              #endif\n              o.positionCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionWS, 1.0f));\n\n              #if defined(HAVE_VFX_MODIFICATION)\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT) || defined(_ADD_PRECOMPUTED_VELOCITY)\n                    #error Unexpected fast path rendering VFX motion vector while there are vertex modification afterwards.\n                  #endif\n                  o.previousPositionCS = VFXGetPreviousClipPosition(previousMesh, currentFrameMvData.vfxElementAttributes, o.positionCS);\n                #else\n                  #if VFX_WORLD_SPACE\n                    //previousPositionOS is already in world space\n                    const float3 previousPositionWS = previousPositionOS;\n                  #else\n                    const float3 previousPositionWS = mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1.0f)).xyz;\n                  #endif\n                  o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionWS, 1.0f));\n                #endif\n              #else\n                o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1)));\n              #endif\n            }\n          #endif\n\n          return o;\n         }\n\n\n            \n\n            // fragment shader\n            half4 Frag (VertexToPixel IN\n               #if NEED_FACING\n                  , bool facing : SV_IsFrontFace\n               #endif\n            ) : SV_Target\n            {\n               UNITY_SETUP_INSTANCE_ID(IN);\n\n               ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n\n               Surface l = (Surface)0;\n\n               l.Albedo = half3(0.5, 0.5, 0.5);\n               l.Normal = float3(0,0,1);\n               l.Occlusion = 1;\n               l.Alpha = 1;\n\n               ChainSurfaceFunction(l, d);\n\n               MetaInput metaInput = (MetaInput)0;\n               metaInput.Albedo = l.Albedo;\n               metaInput.Emission = l.Emission;\n\n               return MetaFragment(metaInput);\n\n            }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"DepthNormals\"\n            Tags\n            {\n               \"LightMode\" = \"DepthNormals\"\n            }\n    \n            // Render State\n             Cull Back\n                ZTest LEqual\n                ZWrite On\n\n               Cull [_CullMode]\n\n\n            HLSLPROGRAM\n\n               #pragma vertex Vert\n   #pragma fragment Frag\n\n            #pragma target 3.0\n\n            #pragma prefer_hlslcc gles\n            #pragma exclude_renderers d3d11_9x\n            #pragma multi_compile_fog\n            #pragma multi_compile_instancing\n            #pragma multi_compile_fragment _ LOD_FADE_CROSSFADE\n            #pragma multi_compile_fragment _ _WRITE_RENDERING_LAYERS\n\n            #define SHADERPASS SHADERPASS_DEPTHNORMALSONLY\n            #define _PASSDEPTH 1\n            #define _PASSDEPTHNORMALS 1\n\n\n            \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n            // this has to be here or specular color will be ignored. Not in SG code\n            #if _SIMPLELIT\n               #define _SPECULAR_COLOR\n            #endif\n\n\n            // Includes\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/RenderingLayers.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n            #include_with_pragmas \"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n            #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/LODCrossFade.hlsl\"\n            \n            \n\n        \n\n               #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float4 probeOcclusion : TEXCOORD8;\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n         #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n            float4 previousPositionCS : TEXCOORD21; // Contain previous transform position (in case of skinning for example)\n            float4 positionCS : TEXCOORD22;\n         #endif\n      };\n\n\n         \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n            \n         CBUFFER_START(UnityPerMaterial)\n\n            \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n         CBUFFER_END\n\n         \n\n         \n\n         \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n         \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n         \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n            #define GetWorldToViewMatrix()     _ViewMatrix\n            #define UNITY_MATRIX_I_V   _InvViewMatrix\n            #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(_ProjMatrix)\n            #define UNITY_MATRIX_I_P   _InvProjMatrix\n            #define GetWorldToHClipMatrix()    _ViewProjMatrix\n            #define UNITY_MATRIX_I_VP  _InvViewProjMatrix\n            #define UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix\n            #define UNITY_MATRIX_PREV_VP _PrevViewProjMatrix\n            #define UNITY_MATRIX_PREV_I_VP _PrevInvViewProjMatrix\n\n            void MotionVectorPositionZBias(VertexToPixel input)\n            {\n                #if UNITY_REVERSED_Z\n                input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n                #else\n                input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n                #endif\n            }\n\n        #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n            \n           #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n             VertexData previousMesh = v;\n           #endif\n           #if !_TESSELLATION_ON\n             ChainModifyVertex(v, o, _Time);\n           #endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // This return the camera relative position (if enable)\n           float3 positionWS = TransformObjectToWorld(v.vertex.xyz);\n           float3 normalWS = TransformObjectToWorldNormal(v.normal);\n           float4 tangentWS = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = positionWS;\n           o.worldNormal = normalWS;\n           o.worldTangent = tangentWS;\n\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          \n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              #if UNITY_VERSION < 60000009\n                OUTPUT_SH(o.worldNormal, o.sh);\n              #endif\n              \n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n                   #if UNITY_VERSION >= 60000009\n                     OUTPUT_SH(o.worldNormal, o.sh);\n                   #endif\n              #elif (defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)) && UNITY_VERSION >= 60000009\n                   OUTPUT_SH4(vertexInput.positionWS, o.worldNormal.xyz, GetWorldSpaceNormalizeViewDir(vertexInput.positionWS), o.sh, o.probeOcclusion);\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n            #if !defined(TESSELLATION_ON)\n              MotionVectorPositionZBias(o);\n            #endif\n\n            o.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n            // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n            bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n            if (!forceNoMotion)\n            {\n              #if defined(HAVE_VFX_MODIFICATION)\n                float3 previousPositionOS = currentFrameMvData.vfxParticlePositionOS;\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  const bool applyDeformation = false;\n                #else\n                  const bool applyDeformation = true;\n                #endif\n              #else\n                const bool hasDeformation = unity_MotionVectorsParams.x == 1; // Mesh has skinned deformation\n                float3 previousPositionOS = hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz;\n\n                #if defined(AUTOMATIC_TIME_BASED_MOTION_VECTORS) && defined(GRAPH_VERTEX_USES_TIME_PARAMETERS_INPUT)\n                  const bool applyDeformation = true;\n                #else\n                  const bool applyDeformation = hasDeformation;\n                #endif\n              #endif\n              // TODO\n              #if defined(FEATURES_GRAPH_VERTEX)\n                if (applyDeformation)\n                  previousPositionOS = GetLastFrameDeformedPosition(previousMesh, currentFrameMvData, previousPositionOS);\n                else\n                  previousPositionOS = previousMesh.positionOS;\n\n                #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT)\n                  previousPositionOS -= previousMesh.precomputedVelocity;\n                #endif\n              #endif\n\n              #if defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(DOTS_DEFORMED)\n                // Deformed vertices in DOTS are not cumulative with built-in Unity skinning/blend shapes\n                // Needs to be called after vertex modification has been applied otherwise it will be\n                // overwritten by Compute Deform node\n                ApplyPreviousFrameDeformedVertexPosition(previousMesh.vertexID, previousPositionOS);\n              #endif\n              #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                previousPositionOS -= previousMesh.precomputedVelocity;\n              #endif\n              o.positionCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionWS, 1.0f));\n\n              #if defined(HAVE_VFX_MODIFICATION)\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT) || defined(_ADD_PRECOMPUTED_VELOCITY)\n                    #error Unexpected fast path rendering VFX motion vector while there are vertex modification afterwards.\n                  #endif\n                  o.previousPositionCS = VFXGetPreviousClipPosition(previousMesh, currentFrameMvData.vfxElementAttributes, o.positionCS);\n                #else\n                  #if VFX_WORLD_SPACE\n                    //previousPositionOS is already in world space\n                    const float3 previousPositionWS = previousPositionOS;\n                  #else\n                    const float3 previousPositionWS = mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1.0f)).xyz;\n                  #endif\n                  o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionWS, 1.0f));\n                #endif\n              #else\n                o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1)));\n              #endif\n            }\n          #endif\n\n          return o;\n         }\n\n\n         \n\n         // fragment shader\n         void Frag (VertexToPixel IN\n            , out half4 outNormalWS : SV_Target0\n         #ifdef _WRITE_RENDERING_LAYERS\n            , out float4 outRenderingLayers : SV_Target1\n         #endif\n            #ifdef _DEPTHOFFSET_ON\n              , out float outputDepth : SV_Depth\n            #endif\n            #if NEED_FACING\n               , bool facing : SV_IsFrontFace\n            #endif\n         )\n         {\n           UNITY_SETUP_INSTANCE_ID(IN);\n           UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);\n\n           #if defined(LOD_FADE_CROSSFADE)\n              LODFadeCrossFade(IN.pos);\n           #endif\n\n           ShaderData d = CreateShaderData(IN\n                  #if NEED_FACING\n                     , facing\n                  #endif\n               );\n           Surface l = (Surface)0;\n\n           #ifdef _DEPTHOFFSET_ON\n              l.outputDepth = outputDepth;\n           #endif\n\n           l.Albedo = half3(0.5, 0.5, 0.5);\n           l.Normal = float3(0,0,1);\n           l.Occlusion = 1;\n           l.Alpha = 1;\n\n           ChainSurfaceFunction(l, d);\n\n           #ifdef _DEPTHOFFSET_ON\n              outputDepth = l.outputDepth;\n           #endif\n\n          #if defined(_GBUFFER_NORMALS_OCT)\n              float3 normalWS = d.worldSpaceNormal;\n              float2 octNormalWS = PackNormalOctQuadEncode(normalWS);           // values between [-1, +1], must use fp32 on some platforms\n              float2 remappedOctNormalWS = saturate(octNormalWS * 0.5 + 0.5);   // values between [ 0,  1]\n              half3 packedNormalWS = PackFloat2To888(remappedOctNormalWS);      // values between [ 0,  1]\n              outNormalWS = half4(packedNormalWS, 0.0);\n          #else\n              float3 wsn = l.Normal;\n              #if !_WORLDSPACENORMAL\n                wsn = TangentToWorldSpace(d, l.Normal);\n              #endif\n              outNormalWS = half4(NormalizeNormalPerPixel(wsn), 0.0);\n          #endif\n\n          #ifdef _WRITE_RENDERING_LAYERS\n            uint renderingLayers = GetMeshRenderingLayer();\n            outRenderingLayers = float4(EncodeMeshRenderingLayer(renderingLayers), 0, 0, 0);\n          #endif\n\n         \n         }\n\n         ENDHLSL\n\n      }\n\n\n      \n        Pass\n        {\n            Name \"MotionVectors\"\n            Tags\n            {\n                \"LightMode\" = \"MotionVectors\"\n            }\n        \n        // Render State\n        Cull Back\n        ZTest LEqual\n        ZWrite On\n        ColorMask RG\n\n           Cull [_CullMode]\n\n\n        HLSLPROGRAM\n\n           #pragma vertex Vert\n   #pragma fragment Frag\n\n        #define _PASSMOTIONVECTOR 1\n\n        #pragma target 3.5\n        #pragma multi_compile_instancing\n        #pragma vertex vert\n        #pragma fragment frag\n\n        #define SHADERPASS SHADERPASS_MOTION_VECTORS\n        #define RAYTRACING_SHADER_GRAPH_DEFAULT\n        #define VARYINGS_NEED_PASS\n        #define _PASSMOTIONVECTOR 1\n        \n        \n\n\n   #define _URP 1\n#define NEED_FACING 1\n\n        #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DOTS.hlsl\"\n        #include_with_pragmas \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/RenderingLayers.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/Input.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl\"\n        #include_with_pragmas \"Packages/com.unity.render-pipelines.core/ShaderLibrary/FoveatedRenderingKeywords.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/ShaderGraphFunctions.hlsl\"\n        #include \"Packages/com.unity.render-pipelines.universal/Editor/ShaderGraph/Includes/ShaderPass.hlsl\"\n         \n              #undef WorldNormalVector\n      #define WorldNormalVector(data, normal) mul(normal, data.TBNMatrix)\n      \n      #define UnityObjectToWorldNormal(normal) mul(GetObjectToWorldMatrix(), normal)\n\n      #define _WorldSpaceLightPos0 _MainLightPosition\n      \n      #define UNITY_DECLARE_TEX2D(name) TEXTURE2D(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2D_NOSAMPLER(name) TEXTURE2D(name);\n      #define UNITY_DECLARE_TEX2DARRAY(name) TEXTURE2D_ARRAY(name); SAMPLER(sampler##name);\n      #define UNITY_DECLARE_TEX2DARRAY_NOSAMPLER(name) TEXTURE2D_ARRAY(name);\n\n      #define UNITY_SAMPLE_TEX2DARRAY(tex,coord)            SAMPLE_TEXTURE2D_ARRAY(tex, sampler##tex, coord.xy, coord.z)\n      #define UNITY_SAMPLE_TEX2DARRAY_LOD(tex,coord,lod)    SAMPLE_TEXTURE2D_ARRAY_LOD(tex, sampler##tex, coord.xy, coord.z, lod)\n      #define UNITY_SAMPLE_TEX2D(tex, coord)                SAMPLE_TEXTURE2D(tex, sampler##tex, coord)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER(tex, samp, coord)  SAMPLE_TEXTURE2D(tex, sampler##samp, coord)\n\n      #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod)   SAMPLE_TEXTURE2D_LOD(tex, sampler_##tex, coord, lod)\n      #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) SAMPLE_TEXTURE2D_LOD (tex, sampler##samplertex,coord, lod)\n     \n      #if defined(UNITY_COMPILER_HLSL)\n         #define UNITY_INITIALIZE_OUTPUT(type,name) name = (type)0;\n      #else\n         #define UNITY_INITIALIZE_OUTPUT(type,name)\n      #endif\n\n      #define sampler2D_float sampler2D\n      #define sampler2D_half sampler2D\n\n      \n\n      // data across stages, stripped like the above.\n      struct VertexToPixel\n      {\n         float4 pos : SV_POSITION;\n         float3 worldPos : TEXCOORD0;\n         float3 worldNormal : TEXCOORD1;\n         float4 worldTangent : TEXCOORD2;\n          float4 texcoord0 : TEXCOORD3;\n         // float4 texcoord1 : TEXCOORD4;\n         // float4 texcoord2 : TEXCOORD5;\n\n         // #if %TEXCOORD3REQUIREKEY%\n         // float4 texcoord3 : TEXCOORD6;\n         // #endif\n\n         // #if %SCREENPOSREQUIREKEY%\n         // float4 screenPos : TEXCOORD7;\n         // #endif\n\n         // #if %VERTEXCOLORREQUIREKEY%\n         // half4 vertexColor : COLOR;\n         // #endif\n\n         #if defined(LIGHTMAP_ON)\n            float2 lightmapUV : TEXCOORD8;\n         #endif\n         #if defined(DYNAMICLIGHTMAP_ON)\n            float2 dynamicLightmapUV : TEXCOORD9;\n         #endif\n         #if !defined(LIGHTMAP_ON)\n            float4 probeOcclusion : TEXCOORD8;\n            float3 sh : TEXCOORD10;\n         #endif\n\n         #if defined(VARYINGS_NEED_FOG_AND_VERTEX_LIGHT)\n            float4 fogFactorAndVertexLight : TEXCOORD11;\n         #endif\n\n         #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n           float4 shadowCoord : TEXCOORD12;\n         #endif\n\n         // #if %EXTRAV2F0REQUIREKEY%\n         // float4 extraV2F0 : TEXCOORD13;\n         // #endif\n\n         // #if %EXTRAV2F1REQUIREKEY%\n         // float4 extraV2F1 : TEXCOORD14;\n         // #endif\n\n         // #if %EXTRAV2F2REQUIREKEY%\n         // float4 extraV2F2 : TEXCOORD15;\n         // #endif\n\n         // #if %EXTRAV2F3REQUIREKEY%\n         // float4 extraV2F3 : TEXCOORD16;\n         // #endif\n\n         // #if %EXTRAV2F4REQUIREKEY%\n         // float4 extraV2F4 : TEXCOORD17;\n         // #endif\n\n         // #if %EXTRAV2F5REQUIREKEY%\n         // float4 extraV2F5 : TEXCOORD18;\n         // #endif\n\n         // #if %EXTRAV2F6REQUIREKEY%\n         // float4 extraV2F6 : TEXCOORD19;\n         // #endif\n\n         // #if %EXTRAV2F7REQUIREKEY%\n         // float4 extraV2F7 : TEXCOORD20;\n         // #endif\n\n         #if UNITY_ANY_INSTANCING_ENABLED\n         uint instanceID : CUSTOM_INSTANCE_ID;\n         #endif\n         #if (defined(UNITY_STEREO_MULTIVIEW_ENABLED)) || (defined(UNITY_STEREO_INSTANCING_ENABLED) && (defined(SHADER_API_GLES3) || defined(SHADER_API_GLCORE)))\n         uint stereoTargetEyeIndexAsBlendIdx0 : BLENDINDICES0;\n         #endif\n         #if (defined(UNITY_STEREO_INSTANCING_ENABLED))\n         uint stereoTargetEyeIndexAsRTArrayIdx : SV_RenderTargetArrayIndex;\n         #endif\n         #if defined(SHADER_STAGE_FRAGMENT) && defined(VARYINGS_NEED_CULLFACE)\n         FRONT_FACE_TYPE cullFace : FRONT_FACE_SEMANTIC;\n         #endif\n\n         #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n            float4 previousPositionCS : TEXCOORD21; // Contain previous transform position (in case of skinning for example)\n            float4 positionCS : TEXCOORD22;\n         #endif\n      };\n\n        \n        \n            \n            // data describing the user output of a pixel\n            struct Surface\n            {\n               half3 Albedo;\n               half Height;\n               half3 Normal;\n               half Smoothness;\n               half3 Emission;\n               half Metallic;\n               half3 Specular;\n               half Occlusion;\n               half SpecularPower; // for simple lighting\n               half Alpha;\n               float outputDepth; // if written, SV_Depth semantic is used. ShaderData.clipPos.z is unused value\n               // HDRP Only\n               half SpecularOcclusion;\n               half SubsurfaceMask;\n               half Thickness;\n               half CoatMask;\n               half CoatSmoothness;\n               half Anisotropy;\n               half IridescenceMask;\n               half IridescenceThickness;\n               int DiffusionProfileHash;\n               float SpecularAAThreshold;\n               float SpecularAAScreenSpaceVariance;\n               // requires _OVERRIDE_BAKEDGI to be defined, but is mapped in all pipelines\n               float3 DiffuseGI;\n               float3 BackDiffuseGI;\n               float3 SpecularGI;\n               float ior;\n               float3 transmittanceColor;\n               float atDistance;\n               float transmittanceMask;\n               // requires _OVERRIDE_SHADOWMASK to be defines\n               float4 ShadowMask;\n\n               // for decals\n               float NormalAlpha;\n               float MAOSAlpha;\n\n\n            };\n\n            // Data the user declares in blackboard blocks\n            struct Blackboard\n            {\n                \n                float blackboardDummyData;\n            };\n\n            // data the user might need, this will grow to be big. But easy to strip\n            struct ShaderData\n            {\n               float4 clipPos; // SV_POSITION\n               float3 localSpacePosition;\n               float3 localSpaceNormal;\n               float3 localSpaceTangent;\n        \n               float3 worldSpacePosition;\n               float3 worldSpaceNormal;\n               float3 worldSpaceTangent;\n               float tangentSign;\n\n               float3 worldSpaceViewDir;\n               float3 tangentSpaceViewDir;\n\n               float4 texcoord0;\n               float4 texcoord1;\n               float4 texcoord2;\n               float4 texcoord3;\n\n               float2 screenUV;\n               float4 screenPos;\n\n               float4 vertexColor;\n               bool isFrontFace;\n\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n\n               float3x3 TBNMatrix;\n               Blackboard blackboard;\n            };\n\n            struct VertexData\n            {\n               #if SHADER_TARGET > 30\n               // uint vertexID : SV_VertexID;\n               #endif\n               float4 vertex : POSITION;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n\n               // optimize out mesh coords when not in use by user or lighting system\n               #if _URP && (_USINGTEXCOORD1 || _PASSMETA || _PASSFORWARD || _PASSGBUFFER)\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n\n               #if _URP && (_USINGTEXCOORD2 || _PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && defined(DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               #if _STANDARD && (_USINGTEXCOORD1 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER || _PASSFORWARDADD) && LIGHTMAP_ON)))\n                  float4 texcoord1 : TEXCOORD1;\n               #endif\n               #if _STANDARD && (_USINGTEXCOORD2 || (_PASSMETA || ((_PASSFORWARD || _PASSGBUFFER) && DYNAMICLIGHTMAP_ON)))\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n\n               #if _HDRP\n                  float4 texcoord1 : TEXCOORD1;\n                  float4 texcoord2 : TEXCOORD2;\n               #endif\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD4; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity    : TEXCOORD5; // Add Precomputed Velocity (Alembic computes velocities on runtime side).\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n            };\n\n            struct TessVertex \n            {\n               float4 vertex : INTERNALTESSPOS;\n               float3 normal : NORMAL;\n               float4 tangent : TANGENT;\n               float4 texcoord0 : TEXCOORD0;\n               float4 texcoord1 : TEXCOORD1;\n               float4 texcoord2 : TEXCOORD2;\n\n               // #if %TEXCOORD3REQUIREKEY%\n               // float4 texcoord3 : TEXCOORD3;\n               // #endif\n\n               // #if %VERTEXCOLORREQUIREKEY%\n               // float4 vertexColor : COLOR;\n               // #endif\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // float4 extraV2F0 : TEXCOORD5;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // float4 extraV2F1 : TEXCOORD6;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // float4 extraV2F2 : TEXCOORD7;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // float4 extraV2F3 : TEXCOORD8;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // float4 extraV2F4 : TEXCOORD9;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // float4 extraV2F5 : TEXCOORD10;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // float4 extraV2F6 : TEXCOORD11;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // float4 extraV2F7 : TEXCOORD12;\n               // #endif\n\n               #if _PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR))\n                  float3 previousPositionOS : TEXCOORD13; // Contain previous transform position (in case of skinning for example)\n                  #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                     float3 precomputedVelocity : TEXCOORD14;\n                  #endif\n               #endif\n\n               UNITY_VERTEX_INPUT_INSTANCE_ID\n               UNITY_VERTEX_OUTPUT_STEREO\n            };\n\n            struct ExtraV2F\n            {\n               float4 extraV2F0;\n               float4 extraV2F1;\n               float4 extraV2F2;\n               float4 extraV2F3;\n               float4 extraV2F4;\n               float4 extraV2F5;\n               float4 extraV2F6;\n               float4 extraV2F7;\n               Blackboard blackboard;\n               float4 time;\n            };\n\n\n            float3 WorldToTangentSpace(ShaderData d, float3 normal)\n            {\n               return mul(d.TBNMatrix, normal);\n            }\n\n            float3 TangentToWorldSpace(ShaderData d, float3 normal)\n            {\n               return mul(normal, d.TBNMatrix);\n            }\n\n            // in this case, make standard more like SRPs, because we can't fix\n            // unity_WorldToObject in HDRP, since it already does macro-fu there\n\n            #if _STANDARD\n               float3 TransformWorldToObject(float3 p) { return mul(unity_WorldToObject, float4(p, 1)); };\n               float3 TransformObjectToWorld(float3 p) { return mul(unity_ObjectToWorld, float4(p, 1)); };\n               float4 TransformWorldToObject(float4 p) { return mul(unity_WorldToObject, p); };\n               float4 TransformObjectToWorld(float4 p) { return mul(unity_ObjectToWorld, p); };\n               float4x4 GetWorldToObjectMatrix() { return unity_WorldToObject; }\n               float4x4 GetObjectToWorldMatrix() { return unity_ObjectToWorld; }\n               #if (defined(SHADER_API_D3D11) || defined(SHADER_API_XBOXONE) || defined(UNITY_COMPILER_HLSLCC) || defined(SHADER_API_PSSL) || (SHADER_TARGET_SURFACE_ANALYSIS && !SHADER_TARGET_SURFACE_ANALYSIS_MOJOSHADER))\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord, lod) tex.SampleLevel (sampler##tex,coord, lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord, lod) tex.SampleLevel (sampler##samplertex,coord, lod)\n              #else\n                 #define UNITY_SAMPLE_TEX2D_LOD(tex,coord,lod) tex2D (tex,coord,0,lod)\n                 #define UNITY_SAMPLE_TEX2D_SAMPLER_LOD(tex,samplertex,coord,lod) tex2D (tex,coord,0,lod)\n              #endif\n\n               #undef GetWorldToObjectMatrix()\n\n               #define GetWorldToObjectMatrix()   unity_WorldToObject\n\n\n            #endif\n\n            float3 GetCameraWorldPosition()\n            {\n               #if _HDRP\n                  return GetCameraRelativePositionWS(_WorldSpaceCameraPos);\n               #else\n                  return _WorldSpaceCameraPos;\n               #endif\n            }\n\n            #if _GRABPASSUSED\n               #if _STANDARD\n                  TEXTURE2D(%GRABTEXTURE%);\n                  SAMPLER(sampler_%GRABTEXTURE%);\n               #endif\n\n               half3 GetSceneColor(float2 uv)\n               {\n                  #if _STANDARD\n                     return SAMPLE_TEXTURE2D(%GRABTEXTURE%, sampler_%GRABTEXTURE%, uv).rgb;\n                  #else\n                     return SHADERGRAPH_SAMPLE_SCENE_COLOR(uv);\n                  #endif\n               }\n            #endif\n\n\n      \n            #if _STANDARD\n               UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);\n               float GetSceneDepth(float2 uv) { return SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv)); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv)); } \n            #else\n               float GetSceneDepth(float2 uv) { return SHADERGRAPH_SAMPLE_SCENE_DEPTH(uv); }\n               float GetLinear01Depth(float2 uv) { return Linear01Depth(GetSceneDepth(uv), _ZBufferParams); }\n               float GetLinearEyeDepth(float2 uv) { return LinearEyeDepth(GetSceneDepth(uv), _ZBufferParams); } \n            #endif\n\n            float3 GetWorldPositionFromDepthBuffer(float2 uv, float3 worldSpaceViewDir)\n            {\n               float eye = GetLinearEyeDepth(uv);\n               float3 camView = mul((float3x3)GetObjectToWorldMatrix(), transpose(mul(GetWorldToObjectMatrix(), UNITY_MATRIX_I_V)) [2].xyz);\n\n               float dt = dot(worldSpaceViewDir, camView);\n               float3 div = worldSpaceViewDir/dt;\n               float3 wpos = (eye * div) + GetCameraWorldPosition();\n               return wpos;\n            }\n\n            #if _HDRP\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return GetAbsolutePositionWS(TransformObjectToWorld(pos));\n            }\n            #else\n            float3 ObjectToWorldSpacePosition(float3 pos)\n            {\n               return TransformObjectToWorld(pos);\n            }\n            #endif\n\n            #if _STANDARD\n               UNITY_DECLARE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture);\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  float4 depthNorms = UNITY_SAMPLE_SCREENSPACE_TEXTURE(_CameraDepthNormalsTexture, uv);\n                  float3 norms = DecodeViewNormalStereo(depthNorms);\n                  norms = mul((float3x3)GetWorldToViewMatrix(), norms) * 0.5 + 0.5;\n                  return norms;\n               }\n            #elif _HDRP && !_DECALSHADER\n               \n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  NormalData nd;\n                  DecodeFromNormalBuffer(_ScreenSize.xy * uv, nd);\n                  return nd.normalWS;\n               }\n            #elif _URP\n               #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                  #include \"Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareNormalsTexture.hlsl\"\n               #endif\n\n               float3 GetSceneNormal(float2 uv, float3 worldSpaceViewDir)\n               {\n                  #if (SHADER_LIBRARY_VERSION_MAJOR >= 10)\n                     return SampleSceneNormals(uv);\n                  #else\n                     float3 wpos = GetWorldPositionFromDepthBuffer(uv, worldSpaceViewDir);\n                     return normalize(-cross(ddx(wpos), ddy(wpos))) * 0.5 + 0.5;\n                  #endif\n\n                }\n             #endif\n\n             #if _HDRP\n\n               half3 UnpackNormalmapRGorAG(half4 packednormal)\n               {\n                     // This do the trick\n                  packednormal.x *= packednormal.w;\n\n                  half3 normal;\n                  normal.xy = packednormal.xy * 2 - 1;\n                  normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                  return normal;\n               }\n               half3 UnpackNormal(half4 packednormal)\n               {\n                  #if defined(UNITY_NO_DXT5nm)\n                     return packednormal.xyz * 2 - 1;\n                  #else\n                     return UnpackNormalmapRGorAG(packednormal);\n                  #endif\n               }\n            #endif\n            #if _HDRP || _URP\n\n               half3 UnpackScaleNormal(half4 packednormal, half scale)\n               {\n                 #ifndef UNITY_NO_DXT5nm\n                   // Unpack normal as DXT5nm (1, y, 1, x) or BC5 (x, y, 0, 1)\n                   // Note neutral texture like \"bump\" is (0, 0, 1, 1) to work with both plain RGB normal and DXT5nm/BC5\n                   packednormal.x *= packednormal.w;\n                 #endif\n                   half3 normal;\n                   normal.xy = (packednormal.xy * 2 - 1) * scale;\n                   normal.z = sqrt(1 - saturate(dot(normal.xy, normal.xy)));\n                   return normal;\n               }\t\n\n             #endif\n\n\n            void GetSun(out float3 lightDir, out float3 color)\n            {\n               lightDir = float3(0.5, 0.5, 0);\n               color = 1;\n               #if _HDRP\n                  if (_DirectionalLightCount > 0)\n                  {\n                     DirectionalLightData light = _DirectionalLightDatas[0];\n                     lightDir = -light.forward.xyz;\n                     color = light.color;\n                  }\n               #elif _STANDARD\n\t\t\t         lightDir = normalize(_WorldSpaceLightPos0.xyz);\n                  color = _LightColor0.rgb;\n               #elif _URP\n\t               Light light = GetMainLight();\n\t               lightDir = light.direction;\n\t               color = light.color;\n               #endif\n            }\n\n\n\n        CBUFFER_START(UnityPerMaterial)\n\n               \n    half4 _Color;\n\thalf  _ColorModulation;\n\thalf  _SmoothnessModulation;\n\thalf  _MetallicModulation;\n    half  _EmissiveModulation;\n    half _HalfLambertStrength;\n    float _DoubleSidedNormalMode;\n    half3 _RimLightColor;\n\thalf  _RimLightPower;\n    float _RimLightingModulation;\n    float _NormalStrength;\n    float _UseHalfLambert;\n    float _UberTile;\n\n\n\n        CBUFFER_END\n\n        \n\n        \n\n        \n\n   TEXTURE2D(_BaseMap);\n   SAMPLER(sampler_BaseMap);\n   TEXTURE2D(_BumpMap);\n   SAMPLER(sampler_BumpMap);\n   TEXTURE2D(_MetallicGlossMap);\n   SAMPLER(sampler_MetallicGlossMap);\n\n\n\tvoid Ext_SurfaceFunction0 (inout Surface o, ShaderData d)\n\t{\n      float2 auv = d.texcoord0.xy * _UberTile;\n      float2 nuv = d.texcoord0.xy * _UberTile;\n      float2 cuv = d.texcoord0.xy * _UberTile;\n      \n\t  half4 mask = SAMPLE_TEXTURE2D(_MetallicGlossMap,sampler_MetallicGlossMap,cuv);\n\t  half4 base_c = SAMPLE_TEXTURE2D(_BaseMap, sampler_BaseMap, auv);\n\t  half4 basepackednormal = SAMPLE_TEXTURE2D(_BumpMap, sampler_BumpMap,nuv);\n\t  half3 base_n = UnpackScaleNormal(basepackednormal,_NormalStrength);\n\n\t  half base_smooth = mask.a;\n\t  half base_Metallic = mask.r;\n\n      //o.Alpha  = base_c.a * _Color.a; \n      o.Albedo = base_c.rgb   * _ColorModulation * _Color.rgb;\n\n\t  o.Normal = base_n;\n\t  o.Metallic = base_Metallic * _MetallicModulation;\n\t  o.Smoothness = base_smooth * _SmoothnessModulation;\n\n      if (_DoubleSidedNormalMode == 0)\n      {\n         o.Normal *= d.isFrontFace ? 1 : -1;\n      }\n      else if (_DoubleSidedNormalMode == 1)\n      {\n\t\t o.Normal.z *= d.isFrontFace ? 1 : -1;\n      }\n\n\n    if (_UseHalfLambert) \n    { \n\t    float3 lightDir;\n        float3 lightColor;\n\t    GetSun(lightDir, lightColor);\n\t    float3 normalDirection = TangentToWorldSpace(d, o.Normal);\n\t    float atten = 1.0;\n\t    float lambert = dot(normalDirection, lightDir);\n\n        lambert = lerp(lambert, lambert * 0.5 + 0.5, _HalfLambertStrength);\n        o.Albedo *= atten * lightColor * lambert;        \n     }\n\n     if (_RimLightingModulation>0) \n     { \n\t    float rim = 1.0 - saturate(dot(d.tangentSpaceViewDir, o.Normal)); \n\t    o.Emission += (pow(rim, _RimLightPower) * _RimLightColor) * _RimLightingModulation;  \n      }\n\t}\n\n\n\n\n        \n            void ChainSurfaceFunction(inout Surface l, inout ShaderData d)\n            {\n                  Ext_SurfaceFunction0(l, d);\n                 // Ext_SurfaceFunction1(l, d);\n                 // Ext_SurfaceFunction2(l, d);\n                 // Ext_SurfaceFunction3(l, d);\n                 // Ext_SurfaceFunction4(l, d);\n                 // Ext_SurfaceFunction5(l, d);\n                 // Ext_SurfaceFunction6(l, d);\n                 // Ext_SurfaceFunction7(l, d);\n                 // Ext_SurfaceFunction8(l, d);\n                 // Ext_SurfaceFunction9(l, d);\n\t\t           // Ext_SurfaceFunction10(l, d);\n                 // Ext_SurfaceFunction11(l, d);\n                 // Ext_SurfaceFunction12(l, d);\n                 // Ext_SurfaceFunction13(l, d);\n                 // Ext_SurfaceFunction14(l, d);\n                 // Ext_SurfaceFunction15(l, d);\n                 // Ext_SurfaceFunction16(l, d);\n                 // Ext_SurfaceFunction17(l, d);\n                 // Ext_SurfaceFunction18(l, d);\n\t\t           // Ext_SurfaceFunction19(l, d);\n                 // Ext_SurfaceFunction20(l, d);\n                 // Ext_SurfaceFunction21(l, d);\n                 // Ext_SurfaceFunction22(l, d);\n                 // Ext_SurfaceFunction23(l, d);\n                 // Ext_SurfaceFunction24(l, d);\n                 // Ext_SurfaceFunction25(l, d);\n                 // Ext_SurfaceFunction26(l, d);\n                 // Ext_SurfaceFunction27(l, d);\n                 // Ext_SurfaceFunction28(l, d);\n\t\t           // Ext_SurfaceFunction29(l, d);\n            }\n\n#if !_DECALSHADER\n\n            void ChainModifyVertex(inout VertexData v, inout VertexToPixel v2p, float4 time)\n            {\n                 ExtraV2F d;\n                 \n                 ZERO_INITIALIZE(ExtraV2F, d);\n                 ZERO_INITIALIZE(Blackboard, d.blackboard);\n                 // due to motion vectors in HDRP, we need to use the last\n                 // time in certain spots. So if you are going to use _Time to adjust vertices,\n                 // you need to use this time or motion vectors will break. \n                 d.time = time;\n\n                 //  Ext_ModifyVertex0(v, d);\n                 // Ext_ModifyVertex1(v, d);\n                 // Ext_ModifyVertex2(v, d);\n                 // Ext_ModifyVertex3(v, d);\n                 // Ext_ModifyVertex4(v, d);\n                 // Ext_ModifyVertex5(v, d);\n                 // Ext_ModifyVertex6(v, d);\n                 // Ext_ModifyVertex7(v, d);\n                 // Ext_ModifyVertex8(v, d);\n                 // Ext_ModifyVertex9(v, d);\n                 // Ext_ModifyVertex10(v, d);\n                 // Ext_ModifyVertex11(v, d);\n                 // Ext_ModifyVertex12(v, d);\n                 // Ext_ModifyVertex13(v, d);\n                 // Ext_ModifyVertex14(v, d);\n                 // Ext_ModifyVertex15(v, d);\n                 // Ext_ModifyVertex16(v, d);\n                 // Ext_ModifyVertex17(v, d);\n                 // Ext_ModifyVertex18(v, d);\n                 // Ext_ModifyVertex19(v, d);\n                 // Ext_ModifyVertex20(v, d);\n                 // Ext_ModifyVertex21(v, d);\n                 // Ext_ModifyVertex22(v, d);\n                 // Ext_ModifyVertex23(v, d);\n                 // Ext_ModifyVertex24(v, d);\n                 // Ext_ModifyVertex25(v, d);\n                 // Ext_ModifyVertex26(v, d);\n                 // Ext_ModifyVertex27(v, d);\n                 // Ext_ModifyVertex28(v, d);\n                 // Ext_ModifyVertex29(v, d);\n\n\n                 // #if %EXTRAV2F0REQUIREKEY%\n                 // v2p.extraV2F0 = d.extraV2F0;\n                 // #endif\n\n                 // #if %EXTRAV2F1REQUIREKEY%\n                 // v2p.extraV2F1 = d.extraV2F1;\n                 // #endif\n\n                 // #if %EXTRAV2F2REQUIREKEY%\n                 // v2p.extraV2F2 = d.extraV2F2;\n                 // #endif\n\n                 // #if %EXTRAV2F3REQUIREKEY%\n                 // v2p.extraV2F3 = d.extraV2F3;\n                 // #endif\n\n                 // #if %EXTRAV2F4REQUIREKEY%\n                 // v2p.extraV2F4 = d.extraV2F4;\n                 // #endif\n\n                 // #if %EXTRAV2F5REQUIREKEY%\n                 // v2p.extraV2F5 = d.extraV2F5;\n                 // #endif\n\n                 // #if %EXTRAV2F6REQUIREKEY%\n                 // v2p.extraV2F6 = d.extraV2F6;\n                 // #endif\n\n                 // #if %EXTRAV2F7REQUIREKEY%\n                 // v2p.extraV2F7 = d.extraV2F7;\n                 // #endif\n            }\n\n            void ChainModifyTessellatedVertex(inout VertexData v, inout VertexToPixel v2p)\n            {\n               ExtraV2F d;\n               ZERO_INITIALIZE(ExtraV2F, d);\n               ZERO_INITIALIZE(Blackboard, d.blackboard);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // d.extraV2F0 = v2p.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // d.extraV2F1 = v2p.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // d.extraV2F2 = v2p.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // d.extraV2F3 = v2p.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // d.extraV2F4 = v2p.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // d.extraV2F5 = v2p.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // d.extraV2F6 = v2p.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // d.extraV2F7 = v2p.extraV2F7;\n               // #endif\n\n\n               // Ext_ModifyTessellatedVertex0(v, d);\n               // Ext_ModifyTessellatedVertex1(v, d);\n               // Ext_ModifyTessellatedVertex2(v, d);\n               // Ext_ModifyTessellatedVertex3(v, d);\n               // Ext_ModifyTessellatedVertex4(v, d);\n               // Ext_ModifyTessellatedVertex5(v, d);\n               // Ext_ModifyTessellatedVertex6(v, d);\n               // Ext_ModifyTessellatedVertex7(v, d);\n               // Ext_ModifyTessellatedVertex8(v, d);\n               // Ext_ModifyTessellatedVertex9(v, d);\n               // Ext_ModifyTessellatedVertex10(v, d);\n               // Ext_ModifyTessellatedVertex11(v, d);\n               // Ext_ModifyTessellatedVertex12(v, d);\n               // Ext_ModifyTessellatedVertex13(v, d);\n               // Ext_ModifyTessellatedVertex14(v, d);\n               // Ext_ModifyTessellatedVertex15(v, d);\n               // Ext_ModifyTessellatedVertex16(v, d);\n               // Ext_ModifyTessellatedVertex17(v, d);\n               // Ext_ModifyTessellatedVertex18(v, d);\n               // Ext_ModifyTessellatedVertex19(v, d);\n               // Ext_ModifyTessellatedVertex20(v, d);\n               // Ext_ModifyTessellatedVertex21(v, d);\n               // Ext_ModifyTessellatedVertex22(v, d);\n               // Ext_ModifyTessellatedVertex23(v, d);\n               // Ext_ModifyTessellatedVertex24(v, d);\n               // Ext_ModifyTessellatedVertex25(v, d);\n               // Ext_ModifyTessellatedVertex26(v, d);\n               // Ext_ModifyTessellatedVertex27(v, d);\n               // Ext_ModifyTessellatedVertex28(v, d);\n               // Ext_ModifyTessellatedVertex29(v, d);\n\n               // #if %EXTRAV2F0REQUIREKEY%\n               // v2p.extraV2F0 = d.extraV2F0;\n               // #endif\n\n               // #if %EXTRAV2F1REQUIREKEY%\n               // v2p.extraV2F1 = d.extraV2F1;\n               // #endif\n\n               // #if %EXTRAV2F2REQUIREKEY%\n               // v2p.extraV2F2 = d.extraV2F2;\n               // #endif\n\n               // #if %EXTRAV2F3REQUIREKEY%\n               // v2p.extraV2F3 = d.extraV2F3;\n               // #endif\n\n               // #if %EXTRAV2F4REQUIREKEY%\n               // v2p.extraV2F4 = d.extraV2F4;\n               // #endif\n\n               // #if %EXTRAV2F5REQUIREKEY%\n               // v2p.extraV2F5 = d.extraV2F5;\n               // #endif\n\n               // #if %EXTRAV2F6REQUIREKEY%\n               // v2p.extraV2F6 = d.extraV2F6;\n               // #endif\n\n               // #if %EXTRAV2F7REQUIREKEY%\n               // v2p.extraV2F7 = d.extraV2F7;\n               // #endif\n            }\n\n            void ChainFinalColorForward(inout Surface l, inout ShaderData d, inout half4 color)\n            {\n               //   Ext_FinalColorForward0(l, d, color);\n               //   Ext_FinalColorForward1(l, d, color);\n               //   Ext_FinalColorForward2(l, d, color);\n               //   Ext_FinalColorForward3(l, d, color);\n               //   Ext_FinalColorForward4(l, d, color);\n               //   Ext_FinalColorForward5(l, d, color);\n               //   Ext_FinalColorForward6(l, d, color);\n               //   Ext_FinalColorForward7(l, d, color);\n               //   Ext_FinalColorForward8(l, d, color);\n               //   Ext_FinalColorForward9(l, d, color);\n               //  Ext_FinalColorForward10(l, d, color);\n               //  Ext_FinalColorForward11(l, d, color);\n               //  Ext_FinalColorForward12(l, d, color);\n               //  Ext_FinalColorForward13(l, d, color);\n               //  Ext_FinalColorForward14(l, d, color);\n               //  Ext_FinalColorForward15(l, d, color);\n               //  Ext_FinalColorForward16(l, d, color);\n               //  Ext_FinalColorForward17(l, d, color);\n               //  Ext_FinalColorForward18(l, d, color);\n               //  Ext_FinalColorForward19(l, d, color);\n               //  Ext_FinalColorForward20(l, d, color);\n               //  Ext_FinalColorForward21(l, d, color);\n               //  Ext_FinalColorForward22(l, d, color);\n               //  Ext_FinalColorForward23(l, d, color);\n               //  Ext_FinalColorForward24(l, d, color);\n               //  Ext_FinalColorForward25(l, d, color);\n               //  Ext_FinalColorForward26(l, d, color);\n               //  Ext_FinalColorForward27(l, d, color);\n               //  Ext_FinalColorForward28(l, d, color);\n               //  Ext_FinalColorForward29(l, d, color);\n            }\n\n            void ChainFinalGBufferStandard(inout Surface s, inout ShaderData d, inout half4 GBuffer0, inout half4 GBuffer1, inout half4 GBuffer2, inout half4 outEmission, inout half4 outShadowMask)\n            {\n               //   Ext_FinalGBufferStandard0(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard1(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard2(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard3(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard4(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard5(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard6(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard7(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard8(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //   Ext_FinalGBufferStandard9(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard10(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard11(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard12(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard13(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard14(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard15(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard16(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard17(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard18(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard19(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard20(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard21(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard22(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard23(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard24(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard25(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard26(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard27(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard28(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n               //  Ext_FinalGBufferStandard29(s, d, GBuffer0, GBuffer1, GBuffer2, outEmission, outShadowMask);\n            }\n#endif\n\n\n        \n\n\n#if _DECALSHADER\n\n        ShaderData CreateShaderData(SurfaceDescriptionInputs IN)\n        {\n            ShaderData d = (ShaderData)0;\n            d.TBNMatrix = float3x3(IN.WorldSpaceTangent, IN.WorldSpaceBiTangent, IN.WorldSpaceNormal);\n            d.worldSpaceNormal = IN.WorldSpaceNormal;\n            d.worldSpaceTangent = IN.WorldSpaceTangent;\n\n            d.worldSpacePosition = IN.WorldSpacePosition;\n            d.texcoord0 = IN.uv0.xyxy;\n            d.screenPos = IN.ScreenPosition;\n\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - d.worldSpacePosition);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(d.worldSpacePosition), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(d.worldSpacePosition, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), d.worldSpaceTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenUV = (IN.ScreenPosition.xy / max(0.01, IN.ScreenPosition.w));\n            // #endif\n\n            return d;\n        }\n#else\n\n         ShaderData CreateShaderData(VertexToPixel i\n                  #if NEED_FACING\n                     , bool facing\n                  #endif\n         )\n         {\n            ShaderData d = (ShaderData)0;\n            d.clipPos = i.pos;\n            d.worldSpacePosition = i.worldPos;\n\n            d.worldSpaceNormal = normalize(i.worldNormal);\n            d.worldSpaceTangent.xyz = normalize(i.worldTangent.xyz);\n\n            d.tangentSign = i.worldTangent.w * unity_WorldTransformParams.w;\n            float3 bitangent = cross(d.worldSpaceTangent.xyz, d.worldSpaceNormal) * d.tangentSign;\n           \n            d.TBNMatrix = float3x3(d.worldSpaceTangent, -bitangent, d.worldSpaceNormal);\n            d.worldSpaceViewDir = normalize(_WorldSpaceCameraPos - i.worldPos);\n\n            d.tangentSpaceViewDir = mul(d.TBNMatrix, d.worldSpaceViewDir);\n             d.texcoord0 = i.texcoord0;\n            // d.texcoord1 = i.texcoord1;\n            // d.texcoord2 = i.texcoord2;\n\n            // #if %TEXCOORD3REQUIREKEY%\n            // d.texcoord3 = i.texcoord3;\n            // #endif\n\n             d.isFrontFace = facing;\n            // #if %VERTEXCOLORREQUIREKEY%\n            // d.vertexColor = i.vertexColor;\n            // #endif\n\n            // these rarely get used, so we back transform them. Usually will be stripped.\n            #if _HDRP\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(GetCameraRelativePositionWS(i.worldPos), 1)).xyz;\n            #else\n                // d.localSpacePosition = mul(GetWorldToObjectMatrix(), float4(i.worldPos, 1)).xyz;\n            #endif\n            // d.localSpaceNormal = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldNormal));\n            // d.localSpaceTangent = normalize(mul((float3x3)GetWorldToObjectMatrix(), i.worldTangent.xyz));\n\n            // #if %SCREENPOSREQUIREKEY%\n            // d.screenPos = i.screenPos;\n            // d.screenUV = (i.screenPos.xy / i.screenPos.w);\n            // #endif\n\n\n            // #if %EXTRAV2F0REQUIREKEY%\n            // d.extraV2F0 = i.extraV2F0;\n            // #endif\n\n            // #if %EXTRAV2F1REQUIREKEY%\n            // d.extraV2F1 = i.extraV2F1;\n            // #endif\n\n            // #if %EXTRAV2F2REQUIREKEY%\n            // d.extraV2F2 = i.extraV2F2;\n            // #endif\n\n            // #if %EXTRAV2F3REQUIREKEY%\n            // d.extraV2F3 = i.extraV2F3;\n            // #endif\n\n            // #if %EXTRAV2F4REQUIREKEY%\n            // d.extraV2F4 = i.extraV2F4;\n            // #endif\n\n            // #if %EXTRAV2F5REQUIREKEY%\n            // d.extraV2F5 = i.extraV2F5;\n            // #endif\n\n            // #if %EXTRAV2F6REQUIREKEY%\n            // d.extraV2F6 = i.extraV2F6;\n            // #endif\n\n            // #if %EXTRAV2F7REQUIREKEY%\n            // d.extraV2F7 = i.extraV2F7;\n            // #endif\n\n            return d;\n         }\n\n#endif\n\n        \n         #if defined(_PASSSHADOW)\n            float3 _LightDirection;\n            float3 _LightPosition;\n         #endif\n\n         #if (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n\n            #define GetWorldToViewMatrix()     _ViewMatrix\n            #define UNITY_MATRIX_I_V   _InvViewMatrix\n            #define GetViewToHClipMatrix()     OptimizeProjectionMatrix(_ProjMatrix)\n            #define UNITY_MATRIX_I_P   _InvProjMatrix\n            #define GetWorldToHClipMatrix()    _ViewProjMatrix\n            #define UNITY_MATRIX_I_VP  _InvViewProjMatrix\n            #define UNITY_MATRIX_UNJITTERED_VP _NonJitteredViewProjMatrix\n            #define UNITY_MATRIX_PREV_VP _PrevViewProjMatrix\n            #define UNITY_MATRIX_PREV_I_VP _PrevInvViewProjMatrix\n\n            void MotionVectorPositionZBias(VertexToPixel input)\n            {\n                #if UNITY_REVERSED_Z\n                input.pos.z -= unity_MotionVectorsParams.z * input.pos.w;\n                #else\n                input.pos.z += unity_MotionVectorsParams.z * input.pos.w;\n                #endif\n            }\n\n        #endif\n\n         // vertex shader\n         VertexToPixel Vert (VertexData v)\n         {\n           VertexToPixel o = (VertexToPixel)0;\n\n           UNITY_SETUP_INSTANCE_ID(v);\n           UNITY_TRANSFER_INSTANCE_ID(v, o);\n           UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);\n\n            \n           #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n             VertexData previousMesh = v;\n           #endif\n           #if !_TESSELLATION_ON\n             ChainModifyVertex(v, o, _Time);\n           #endif\n\n            o.texcoord0 = v.texcoord0;\n           // o.texcoord1 = v.texcoord1;\n           // o.texcoord2 = v.texcoord2;\n\n           // #if %TEXCOORD3REQUIREKEY%\n           // o.texcoord3 = v.texcoord3;\n           // #endif\n\n           // #if %VERTEXCOLORREQUIREKEY%\n           // o.vertexColor = v.vertexColor;\n           // #endif\n\n           // This return the camera relative position (if enable)\n           float3 positionWS = TransformObjectToWorld(v.vertex.xyz);\n           float3 normalWS = TransformObjectToWorldNormal(v.normal);\n           float4 tangentWS = float4(TransformObjectToWorldDir(v.tangent.xyz), v.tangent.w);\n           \n           VertexPositionInputs vertexInput = GetVertexPositionInputs(v.vertex.xyz);\n           o.worldPos = positionWS;\n           o.worldNormal = normalWS;\n           o.worldTangent = tangentWS;\n\n\n          // For some very odd reason, in 2021.2, we can't use Unity's defines, but have to use our own..\n          #if _PASSSHADOW\n              #if _CASTING_PUNCTUAL_LIGHT_SHADOW\n                 float3 lightDirectionWS = normalize(_LightPosition - o.worldPos);\n              #else\n                 float3 lightDirectionWS = _LightDirection;\n              #endif\n              // Define shadow pass specific clip position for Universal\n              o.pos = TransformWorldToHClip(ApplyShadowBias(o.worldPos, o.worldNormal, lightDirectionWS));\n              #if UNITY_REVERSED_Z\n                  o.pos.z = min(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #else\n                  o.pos.z = max(o.pos.z, UNITY_NEAR_CLIP_VALUE);\n              #endif\n          #elif _PASSMETA\n              o.pos = MetaVertexPosition(float4(v.vertex.xyz, 0), v.texcoord1.xy, v.texcoord2.xy, unity_LightmapST, unity_DynamicLightmapST);\n          #else\n              o.pos = TransformWorldToHClip(o.worldPos);\n          #endif\n\n          // #if %SCREENPOSREQUIREKEY%\n          // o.screenPos = ComputeScreenPos(o.pos, _ProjectionParams.x);\n          // #endif\n\n          \n          #if _PASSFORWARD || _PASSGBUFFER\n              float2 uv1 = v.texcoord1.xy;\n              OUTPUT_LIGHTMAP_UV(uv1, unity_LightmapST, o.lightmapUV);\n              // o.texcoord1.xy = uv1;\n              #if UNITY_VERSION < 60000009\n                OUTPUT_SH(o.worldNormal, o.sh);\n              #endif\n              \n              #if defined(DYNAMICLIGHTMAP_ON)\n                   o.dynamicLightmapUV.xy = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;\n                   #if UNITY_VERSION >= 60000009\n                     OUTPUT_SH(o.worldNormal, o.sh);\n                   #endif\n              #elif (defined(PROBE_VOLUMES_L1) || defined(PROBE_VOLUMES_L2)) && UNITY_VERSION >= 60000009\n                   OUTPUT_SH4(vertexInput.positionWS, o.worldNormal.xyz, GetWorldSpaceNormalizeViewDir(vertexInput.positionWS), o.sh, o.probeOcclusion);\n              #endif\n          #endif\n\n          #ifdef VARYINGS_NEED_FOG_AND_VERTEX_LIGHT\n              half fogFactor = 0;\n              #if defined(_FOG_FRAGMENT)\n                fogFactor = ComputeFogFactor(o.pos.z);\n              #endif\n              #if _BAKEDLIT\n                 o.fogFactorAndVertexLight = half4(fogFactor, 0, 0, 0);\n              #else\n                 half3 vertexLight = VertexLighting(o.worldPos, o.worldNormal);\n                 o.fogFactorAndVertexLight = half4(fogFactor, vertexLight);\n              #endif\n          #endif\n\n          #if defined(REQUIRES_VERTEX_SHADOW_COORD_INTERPOLATOR)\n             o.shadowCoord = GetShadowCoord(vertexInput);\n          #endif\n\n          #if _URP && (_PASSMOTIONVECTOR || ((_PASSFORWARD || _PASSUNLIT) && defined(_WRITE_TRANSPARENT_MOTION_VECTOR)))\n            #if !defined(TESSELLATION_ON)\n              MotionVectorPositionZBias(o);\n            #endif\n\n            o.previousPositionCS = float4(0.0, 0.0, 0.0, 1.0);\n            // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n            bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n\n            if (!forceNoMotion)\n            {\n              #if defined(HAVE_VFX_MODIFICATION)\n                float3 previousPositionOS = currentFrameMvData.vfxParticlePositionOS;\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  const bool applyDeformation = false;\n                #else\n                  const bool applyDeformation = true;\n                #endif\n              #else\n                const bool hasDeformation = unity_MotionVectorsParams.x == 1; // Mesh has skinned deformation\n                float3 previousPositionOS = hasDeformation ? previousMesh.previousPositionOS : previousMesh.vertex.xyz;\n\n                #if defined(AUTOMATIC_TIME_BASED_MOTION_VECTORS) && defined(GRAPH_VERTEX_USES_TIME_PARAMETERS_INPUT)\n                  const bool applyDeformation = true;\n                #else\n                  const bool applyDeformation = hasDeformation;\n                #endif\n              #endif\n              // TODO\n              #if defined(FEATURES_GRAPH_VERTEX)\n                if (applyDeformation)\n                  previousPositionOS = GetLastFrameDeformedPosition(previousMesh, currentFrameMvData, previousPositionOS);\n                else\n                  previousPositionOS = previousMesh.positionOS;\n\n                #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT)\n                  previousPositionOS -= previousMesh.precomputedVelocity;\n                #endif\n              #endif\n\n              #if defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(DOTS_DEFORMED)\n                // Deformed vertices in DOTS are not cumulative with built-in Unity skinning/blend shapes\n                // Needs to be called after vertex modification has been applied otherwise it will be\n                // overwritten by Compute Deform node\n                ApplyPreviousFrameDeformedVertexPosition(previousMesh.vertexID, previousPositionOS);\n              #endif\n              #if defined (_ADD_PRECOMPUTED_VELOCITY)\n                previousPositionOS -= previousMesh.precomputedVelocity;\n              #endif\n              o.positionCS = mul(UNITY_MATRIX_UNJITTERED_VP, float4(positionWS, 1.0f));\n\n              #if defined(HAVE_VFX_MODIFICATION)\n                #if defined(VFX_FEATURE_MOTION_VECTORS_VERTS)\n                  #if defined(FEATURES_GRAPH_VERTEX_MOTION_VECTOR_OUTPUT) || defined(_ADD_PRECOMPUTED_VELOCITY)\n                    #error Unexpected fast path rendering VFX motion vector while there are vertex modification afterwards.\n                  #endif\n                  o.previousPositionCS = VFXGetPreviousClipPosition(previousMesh, currentFrameMvData.vfxElementAttributes, o.positionCS);\n                #else\n                  #if VFX_WORLD_SPACE\n                    //previousPositionOS is already in world space\n                    const float3 previousPositionWS = previousPositionOS;\n                  #else\n                    const float3 previousPositionWS = mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1.0f)).xyz;\n                  #endif\n                  o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, float4(previousPositionWS, 1.0f));\n                #endif\n              #else\n                o.previousPositionCS = mul(UNITY_MATRIX_PREV_VP, mul(UNITY_PREV_MATRIX_M, float4(previousPositionOS, 1)));\n              #endif\n            }\n          #endif\n\n          return o;\n         }\n\n\n        \n        \n        // Using parts of com.unity.render-pipelines.universal\\Editor\\ShaderGraph\\Includes\\MotionVectorPass.hlsl\n        //                com.unity.render-pipelines.universal\\ShaderLibrary\\MotionVectorsCommon.hlsl\n        //                com.unity.render-pipelines.universal\\Editor\\ShaderGraph\\Includes\\Varyings.hlsl\n\n        float2 CalcNdcMotionVectorFromCsPositions(float4 posCS, float4 prevPosCS)\n        {\n          // Note: unity_MotionVectorsParams.y is 0 is forceNoMotion is enabled\n          bool forceNoMotion = unity_MotionVectorsParams.y == 0.0;\n          if (forceNoMotion)\n            return float2(0.0, 0.0);\n\n          // Non-uniform raster needs to keep the posNDC values in float to avoid additional conversions\n          // since uv remap functions use floats\n          float2 posNDC = posCS.xy * rcp(posCS.w);\n          float2 prevPosNDC = prevPosCS.xy * rcp(prevPosCS.w);\n\n          float2 velocity;\n          #if defined(SUPPORTS_FOVEATED_RENDERING_NON_UNIFORM_RASTER)\n            UNITY_BRANCH if (_FOVEATED_RENDERING_NON_UNIFORM_RASTER)\n            {\n              // Convert velocity from NDC space (-1..1) to screen UV 0..1 space since FoveatedRendering remap needs that range.\n              float2 posUV = RemapFoveatedRenderingResolve(posNDC * 0.5 + 0.5);\n              float2 prevPosUV = RemapFoveatedRenderingPrevFrameLinearToNonUniform(prevPosNDC * 0.5 + 0.5);\n\n              // Calculate forward velocity\n              velocity = (posUV - prevPosUV);\n              #if UNITY_UV_STARTS_AT_TOP\n                velocity.y = -velocity.y;\n              #endif\n            }\n            else\n          #endif\n            {\n              // Calculate forward velocity\n              velocity = (posNDC.xy - prevPosNDC.xy);\n              #if UNITY_UV_STARTS_AT_TOP\n                velocity.y = -velocity.y;\n              #endif\n\n              // Convert velocity from NDC space (-1..1) to UV 0..1 space\n              // Note: It doesn't mean we don't have negative values, we store negative or positive offset in UV space.\n              // Note: ((posNDC * 0.5 + 0.5) - (prevPosNDC * 0.5 + 0.5)) = (velocity * 0.5)\n              velocity.xy *= 0.5;\n            }\n\n          return velocity;\n        }\n\n        float4 Frag(\n          VertexToPixel input) : SV_Target\n          {\n            UNITY_SETUP_INSTANCE_ID(input);\n\n            float4 motionVector = float4(CalcNdcMotionVectorFromCsPositions(input.positionCS, input.previousPositionCS), 0, 0);\n    \n            return motionVector;\n          }\n\n        ENDHLSL\n        }\n      \n\n\n      \n\n   }\n   \n   \n   \n}\n"}],"betterShader":{"fileID":-6465566751694194690,"guid":"363c26bce6d95c143a8ac6d179d0217c","type":3},"betterShaderPath":"Assets/SourceShaders/SRPShaders/Opaque/UMA_DiffuseNormalMetallic.surfshader","optionOverrides":{"shaderName":"","useCustomEditor":false,"customEditor":"","fallback":{"instanceID":0}}}}